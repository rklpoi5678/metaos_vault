
## 역사
싱글 페이지 (SPA)대표적인 프레임워크인 앵귤러와 뷰는 기본적으로 양방향 데이터 바인딩을 사용한다.

리액트는 단방향 데이터 바인딩과 더불어 Flux라는 개념을 도입하여 데이터 흐름이 한쪽 방향으로만 진행되는 것을 권장하고 있다.

### 가상돔
정적 웹 이나 자바스크르립트 -> 돔 변경 -> 크게 문제가 안됨
SPA처럼 user와 상호작용이 많다 -> 돔 변경이 동시 다발적 -> 애플리케이션에 성능 문제가 발생

리액트는 메모리상 가상 돔 트리에서 모든 연산을 한 후 실제 돔 트리를 ㅐㅇ신하는 방식으로 리플로와 리페인트의 연산을 최소화

### 선헌형 프로그래밍
명령형 프로그래밍은 "어떻게"집중 프로그래밍법
선언형 프로그래밍은 "무엇에" 집중 프로그래밍법

### 컴포넌트
리액트는 작고 고립된 코드들을 이용한다.
레고처럼 조합하여 페이지를 제작하는 컴포넌트 프로그래밍을한다

## 리액트 개발환경
1) 초콜리티 설치: 윈도우 에서 패키지를 설치하고 관리할 수 있는 윈도우용 패키지 관리자
2) create-react-app사용하여 가능
3) 스크립트 태그 추가로 가능
4) 웹팩이나 Babel을 설정하여 개발 (페북에서 create-react-app이라는 CLI툴을 만들어 배포하여 복잡한 웹팩이나 Babel을 설정하지 않아도 간단하게 리액트 프로젝트를 생성하고 개발할수있다.)
5) Next.js 프레임워크 : 외부 라이브러리 x 여도 SSR과 같은 리치 기능 제공 리액트에 익숙하지 않다면 어디까지가 리액트이고 어디까지가 프레임워크의 기능인지 구분하기 어렵다
6) 리액트는 컴포넌트 중심으로 개발한다, 그러므로 <link /> 태그를 사용하여 CSS를 한 곳에서 관리하게 되면, 어떤 컴포넌트에서 어떤 스타일을 사용하고 있는지 쉽고 빠르게 이해할 수 없다.

#### typescript: 타입스크립트 라이브러리
#### @types/node: 자바스크립트 런타임인 노드 타입이 정의된 타입 정의
#### @types/react: 리액트의 타입이 정의된 타입 정의 파일
#### @types/react-dom: react-dom의 타입이 정의된 타입 정의 파일
tsconfig.json파일을 생성하고 타입스크립트 프로젝트를 컴파일하기 위한 여러 가지 옵션을 설정할수있는 파일이다.
-> 설정이 끝나면 .js파일을 .tsx파일로 변경한다.
-> tsx는 JSX파일을 의미, .ts파일은 TypeScriptJavaScript 파일을 의미
->d.ts파일은 타입 정의 파일로 타입스크립트가 인식하지 못하는 타입이지만, 타입스크립트 안에서 사용할 특정 타입들을 정의할 때 사용한다.

실무에서는 CSS-in-JS를 많이 사용한다.

## ESLint
ES(ECMAScript)와 Lint(에러 코드 표식)의 합성어, 잠재오류나 버그를 찾는 데 도움을 주는 정적 분석 툴이다. Prettier와 함께 자주 사용된다.

## 카운터 앱 - Props와 State
Props와 State는 리액트의 핵심 개념 중 하나.
이 두개를 뺴고서는 리액트를 이야기할 수 없다.
Props는 -> Properties로 특성이라는 의미 즉, 컴포넌트의 특성
(부모 -> 자식 컴포넌트로 데이터를 전달가능 다만 자식 컴포넌트에서는 부모컴포넌트로 부터 전달받은 데이터므로 자식 컴포에서 수정불가)

State는 '상태' -> 컴포넌트 상태 변경 가능 -> 유동적인 데이터를 다룰때사용

### State
예를들어 카운터앱에서 더하기,빼기 -> 카운터 값이 변경, 변경된 화면이 표시될때 즉, 화면에 표시된 0이라는 숫자가 State에 의해 관리돼야하는 변수인것ㄷ

### Props,State요약
Props는 부모 컴포넌트로부터 자식 컴포넌트로 전달되는 데이터이고, State는 한 컴포넌트 안에서 유동적인 데이터를 다룰 떄에 사용한다는 것을 배웠다. 이 두가지는 리액트에 핵심이며 이를 뺴고는 개발이 불가능하다.

## 클래스 컴포넌트
타입스크립트의 제네릭이란 여러 타입에 동작하는 컴포넌트를 제작할 때에 사용하는 기술이다.
부모 컴포로 전달받은ㄷ 데이터인 Props는 this.props를 통해 접근하여 사용할 수 있다.

클래스 컴포는 기본적으로 클래스이므로 생성자 함수를 사용할 수 있다. 생성자 함수는 State를 초기화 하는 데 활용된다. 생성자 함수를 사용할 대에는 super(props)를 통해 상속받은 클래스(Component)에 Props를 전달해 주어야한다.

### 라이프사이클 함수
* constructor 함수: 클래스의 생성자 함수를 사용할 수 있다. state를 사용하지 않아 state의 초깃값을 설정할 필요 없다면, 생상자 함수도 생략이 가능하다.
* render함수: 화면 표시 부분(렌더링 되는 부분)을 정의하는 데 사용한다.즉, render 함수의 반환값이 화면에 표시되게 한다.
* getDerivedStateFromProps함수: 부모 컴포로 받은 Props와 State를 동기화할 때에 사용된다.
* componectDidMount 함수: 클래스 컴포넌트가 처음으로 화면에 표시된 후 componentDidMount함수가 호출, Ajax를 통한 데이터 습득이나 다른 자바스크립트 라이브러리와 연동을 수행할 때에 주로 사용된다.
### 요약
SPA를 제작하는 라이브러리인 리액트에서도 앱과 동일 하게 라이프사이클 함수가 있는 것이 어쩌면 당연한 일일지도 모른다.

함수 컴포넌트를 집중해서 공부하길 추천한다. 현재 많은 라이브러리, 예제들이 함수 컴포넌트를 사용하고 있지만, 여전히 클래스 컴포넌트를 사용하는 라이브러리나 예제들을 찾아볼수 있다.

## 데이터사용
리액트에서는 위에서 아래로, 한쪽방향으로만 전달가능
매번 공통 부모 컴포를 수정하고 컴포넌트까지의 모든 컴포를 Props로 전달하여 데이터를 수정하는것은 비효율

그래서 Flux라는 개념을 도입 그에 걸맞는 Context API를 제공하기 시작
해당 Context의 프로바이더와 컨ㅅ머를 생성해야한다.

## Package.json 수정
ESLint의 룰에 맞게 파일들을 수정하고
npm run format:fix
npm run lint:fix 명령어를 실행하여 Prettier와 ESLint의 룰을 잘 지키고 있는지확인한다.

## KEY
map을 통해 동일한 컴포넌트를 반복적으로 표시할 때에는 Key값을 필수로 설정해 주어야 한다. key값은 반드시 유일한 값이어야 한다. 키값이 동일하면 컴포로 간주하여 동일한 키값을 가지는 컴포가 렌더링시 다른 컴포도 렌더링이됨

## ContextApi 요약
부모 컴포로 부터 데이터를 전달받기 위한 Props 한 컴포안에서 동적인 데이터를 다뤼 위한 State 그리고 전역 데이터를 다루는 Context API를 다룰수있게 됐다. -> 상태관리로 Redux,Mobx,Zustand 라이브러리를 사용한다.

## React-router
리액트는 UI를 만들기 위한 자바스크립트 라이브러리 따라서 리액트는 페이지 이동과 같이 UI와 관계없는 기능은 지원안한다.
그래서 react-router라는 외부 라이브러리를 사용하여 페이지 이동을 구현해야 한다.

## Fetch API
서버에 있는 데이터를 불러오거나 서버에 데이터를 전송하는 방법
자바스크립트는 Ajax를 사용하게 된다. 이전에 XMLHttpRequest를 사용하여 서버에 있는 데이터를 저장하거나 불러왔지만, 최근에는 Fetch API를 사용하여 서버에 있는 데이터를 가져오거나 저장한다.

실무에서는 Fetch API 대신 Axios를 사용하는 곳이 많다. Axios는 Fetch API를 좀 더 사용하기 쉽게 만들어진 라이브러리이다.

## 컴포넌트 주도 개발(CDD, Componect Driven Development)
컴포넌트 라는 기본 단위의 개발을 시작으로 사용자에게 보여지는 최종적인 화면을 점진적으로 결합해 가는 방식으로 개발하는 방법론을 의미한다. 복잡한 화면을 작고 견고한 컴포넌트로 분리하고 이런 컴포넌트들을 재사용함으로써 개발 속도를 향상시키며 큰 프론트엔드 프로젝트에서도 쉽고 빠르게 개발할 수 있도록 도와준다.

### 아토믹 디자인
나눈 컴포넌트를 어떻게 관리할 것인가에 대한내용이다.
- 원자: 더 이상 분해할 수 없는 가장 기본 단위가 되는 컴포넌트(Label,Input,Button)과 같이 모든 컴포넌트들의 기초 또한 HTML 태그, 글꼴, 애니메이션, 컬러 팔레트 또는 레이아웃과 같은 추상적인 요소 포함
- 분자: 한 개 이상의 원자가 특정 목적을 위해 결합한 컴포넌트 (폼 같이 자주사용하는 Label과 Input 입력창 하단에 표시하는 에러 메시지등을 하나의 컴포넌트로 묶어서 제공) 이와 같은 컴포넌트를 분자로 분리할수있다.
- 유기체: 분자보다 좀 더 복잡 특정 컨텍스트, 특정영역에서 사용되는 컴포넌트, 사용자에게 의미를 전달, 인터렉션을 할 수 있는 UI제공( 다만 원자, 분자와 다르게 재사용성이 크게 줄어든다. Header,Footer, 사이드 메뉴는 유기체로써 컴포넌트로 볼수있다)
- 템플릿: 레이아웃과 같은 개념, 원자,분자,유기체를 사용하여 실제 컴포넌트를 화면에 배치하고 페이지의 구조를 잡는데 사용(와이어 프레임, 또는 페이지의 스켈레톤으로 볼 수 있다.)
- 페이지: 템플릿에 실제 콘텐츠를 표시하여 사용자가 볼 수 있는 최종 화면을 의미, 템플릿의 구체화된 인스턴스로 볼 수 있다. 사용자와의 인터렉션을 처리해야 하므로 사이드 이펙트가 발생할수밖에 없는 컴포넌트, 일반적으로 하나의 URL에 하나의 페이지만 존재
- 아토믹 디자인은 개발자보다 디자인 시스템을 위한 개념이다. 개발에는 조금 부적합할 수 있지만, 아토믹 디자인을 사용하면 컴포넌트들을 좀더 쉽게 나누고 관리할 수 있다.

### 스토리북
스토리북은 작고 고립된 컴포넌트를 빠르고 쉽게 만들 수 있게 하며 하나의 컴포넌트에 집중하여 개발할 수 있게 해준다.
스토리북은 legacy-peer-deps를 사용하지 않으면 여러 문제들이 발생한다.

### legacy-peer-deps
npm이 버전 7부터 peerDependencies(동반의존성)를 자동으로 설치하도록 바뀌었다. 그런데 가끔 패키지를 설치하려고 하면, 기존 프로젝트의 의존성과 충돌이 생겨서 설치가 안될때가 있다.

이를 해결하는 방법이 해당옵션이다. npm이 이전방식(4~6버전처럼) peerDependencies충돌을 무시하고 설치해준다. 즉, 의존성이 안 맞지만, 그냥 설치해라!

그러므로 주의점! 충돌을 무시하고 설치하기 때문에, 나중에 예상치 못한 오류가 발생할수있다. 그래서 꼭 필요한 경우에만 사용하는게 좋다.

## Lefthook
ESLint와 Prettier는 여러 개발자들과 함께 개발할 때에 일관된 코드 스타일과 문제점을 빠르게 찾을 수 있어 실무에 많이 사용된다. 실무에서는 모든 개발자들이 동일한 에이터나 개발환경을 갖추고 있지 않기 때문에 CI/CD를 사용하여 정적 분석을 하여 동일한 환경에서 일관된 스타일을 유지하고 문제점을 찾도록 설정한다.

이를 자동화하기 위한 툴은 Lefthook
Git에 특정 명령어(push,commit 등) 실행이 발생하면, 해당 명령어가 실행되기 전에 다른 명령어들을 실행할 수 있도록 도와주는 툴이다.