## 서브쿼리란?
>  따로 쿼리창을 열러 알고난다음 넣지않고 편하게 선언을 할수있게 해준다.
```sql
select  i.id, i.name, AVG(star) AS avg_star
from item AS  i LEFT OUTER JOIN review AS r
ON r.item_id = i.id
group by i.id, i.name
having avg_star < (review테이블에서 전체 평균 별점값을모름)
order by avg_star DESC;
```

```sql
## 굳이 다른 쿼리에서 계산한다음 넣어도되지만 그냥 선언식에다 넣을수있다.
select  i.id, i.name, AVG(star) AS avg_star
from item AS  i LEFT OUTER JOIN review AS r
ON r.item_id = i.id
group by i.id, i.name
having avg_star < (select AVG(star) from review)
order by avg_star DESC; 
```
> 부품처럼 하나의 또다른 쿼리가 또 SQL문안에 들어있다.
> 이러한 서브쿼리를 사용할려면 괄호를 사용해야 오류가 안납니다.

## SELECT절에 있는 서브쿼리
> 원래 컬럼에없던 컬럼을 새로 추가해서 보겠다는말이다.
```sql
select
    id,name,price,(select AVG(price) from item) AS avg_price
from
	item;
```

##  WHERE 절에 있는 서브쿼리 1
```sql
select
    id,
    name,
    price,
    (select AVG(price) from item) AS avg_price
from
    item
WHERE price > (select AVG(price) from item)
```
> 이런식으로 가격의 전체 평균 보다 높은 가격만 볼수있게할수있다.

##  WHERE 절에 있는 서브쿼리 2
아이템에  리뷰수가 3개이상이것들을 보고싶다면?
join
```sql
select
* 
from
item AS i LEFT OUTER JOIN review AS r
on i.id = r.id
where r.star >= 3
```

```sql
select
* 
from
item
where id IN 
(
    select item_id from review group by item_id HAVING COUNT(star) >= 3
)
```

## ANY(SOME).ALL
**ANY(SOME)**
~중에 하나라는 뜻을 가지는 단어고, 안에 들어가는 값중 하나라도 조건을 만족하는지 검사해주는 연산자이다.
```sql
select view_count from theater where category = "ACTION"

...

select * from theater
	where view_count > ANY(select view_count from theater where category = ACTION) AND category != "ACTION"
```
> ANY가 WHERE절에 사용될때는 서브 쿼리의 결과에 있는 각 로우의 값 중 하나라도 만족하면 트루를  리턴한다.
view _count  > AYN(...) 라는 말은 ANY값중에 하나라도 크면 트루라는말로
12000,23000,60000000,5555555 가 있을때 최소값인 12000보다 크기만 하면 된다는 말이된다.

SOME()도 ANY와 동일한 기능을 한다.

**ALL**
```sql
select view_count from theater where category = "ACTION"

...

select * from theater
	where view_count > ALL(select view_count from theater where category = ACTION) AND category != "ACTION"

```
> ALL은 위에 예제로든 4개 값보다 커야 트루가되므로 최대값인 60000000을 넘어야 트루가 된다.

## FROM절에 있는 서브쿼리
```sql
select
    SUBSTRING(address, 1, 2) AS region,
    COUNT(*) AS review_count
FROM review AS r LEFT OUTER JOIN member AS m
ON r.mem_id = m.id
GROUP BY SUBSTRING(address, 1, 2)
HAVING region IS NOT NULL
    AND region != '안드';
```
>위의 한테이블을 서브쿼리로 사용한다면

```sql
select AVG(review_count)
FROM
(select
    SUBSTRING(address, 1, 2) AS region,
    COUNT(*) AS review_count
FROM review AS r LEFT OUTER JOIN member AS m
ON r.mem_id = m.id
GROUP BY SUBSTRING(address, 1, 2)
HAVING region IS NOT NULL
    AND region != '안드') AS review_count_summary;
```
> 위에 서브쿼리는 테이블이라고 하고 derived(파생시키다,도출해내다라는 뜻) table(디라이브드 테이블)이라고 한다. (규칙은 무조건 alias를 붙여줘야한다.)

## WITH문과 서브쿼리
만들다 보면 복잡한데 이럴때는 WITH문을 사용해서 서브쿼리 부분을 분리해서 정리하면 좋다.
WITH키워드 뒤에 테이블 이름을 쓰고, AS뒤에 괄호로 감싼 서브쿼리를 넣어주면된다.
WITH문을 사용하면 서브쿼리를 통해 만든 결과를 임시 테이블로 저장할수있으며 
CTE(Common Table Expression, 공통 테이블 표현식)라고도 한다.
이렇게 정의해두면 실제 이어지는 쿼리에서 실제 테이블처럼 자유롭게 사용할수있다.
```sql
WITH review_count_summary AS (
    SELECT
        SUBSTRING(address, 1, 2) AS region,
        COUNT(*) AS review_count
    FROM review AS r
    LEFT OUTER JOIN member AS m
    ON r.mem_id = m.id
    GROUP BY SUBSTRING(address, 1, 2)
    HAVING region IS NOT NULL
        AND region != '안드'
)

SELECT
    AVG(review_count),
    MAX(review_count),
    MIN(review_count)
FROM review_count_summary;

```
> 중복으로 사용할필요가 없어진다.