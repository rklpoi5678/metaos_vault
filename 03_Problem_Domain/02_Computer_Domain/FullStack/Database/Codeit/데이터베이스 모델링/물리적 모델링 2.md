## Composite 인덱스
2개  또는 더많은 여러 조건을 사용해서 조회를 많이 할 때는 컬럼 하나가 아니라 여러 개에 대해서 인덱스를 만들수있다.![[Pasted image 20251001183145.png]]
> 심지어 브랜드와 종류, 색에 대한  인덱스를 만들고 싶으면, 아래처럼 만들수도 있다.

![[Pasted image 20251001183209.png]]
주의점
	- 아무리 브랜드, 종류, 색 컬럼들에 대한 인덱스 3개를  만들어놔도, 브랜드,종류,색 모두에 대한 인덱스와는 다르다.
	- 여러 컬럼들에 대한 인덱스를 만들 때 순서가 중요하다. 항상 가장 왼쪽에 조건으로 가장 많이 사용하는 컬럼을 사용하고, 오른쪽으로 갈수록 조건으로 덜 사용하는 컬럼을 사용해야 한다. 이렇게 하면  인덱스를 여러개 저장하지않고, 조회를 빨리할 수 있는  효과를 만들수있다.

## 인덱스 단점과 사용
**용량 문제**
(본문: 200페이지,  인덱스: 10페이지 -> 210페이지가되어버림)
논클러스트도 마찬가지 -> 배보다 배꼽이 더커질수있다.

**인덱스 업데이트 문제**
하나의  로우 값을 바꾸면, 해당 컬럼이 포함된 모든 인덱스를 바꿔야함
인덱스는 조회는 빠르게 할 수 있게 하지만, 삽입, 업데이트 ,삭제는 오히려 더 느리게 만든다.

인덱스를 추가하려는 테이블의 컬럼들이 얼마나 자주삽입,업데이트,  삭제되는지 파악
연산들을  많이 해야하는 테이블의 컬럼들에는  인덱스가 오히려 역효과를 낳는다.

**인덱스  추가 기본원칙**
- 모든  PK 에 대해 인덱스를 만들어준다.
- 모든 FK 에 대해 인덱스를 만들어준다.
- 특정 조회 쿼리가 너무 느려지거나, 느려질 게 확실한 경우 조회에 사요오디는 컬럼들에 대해 인덱스를 만들어준다.

## SQL로 인덱스 만들고 사용하기
**인덱스 관리하기 코드**

**Clustered 인덱스 만들기**
pk 로 설정된 클러스티드 인덱스를 바꾸는 경우는 많지 않다.
1. clustered 인덱스는 테이블당 하나씩 밖에 있을 수 없기 때문에, 먼저 기존 인덱스를 삭제한 후 (노트 아래에 삭제하는 방법이 나와 있습니다)
2. 해당 코드를 사용해서 인덱스를 추가합니다 `CREATE CLUSTERED INDEX index_name ON table_name (column_name)`

**Non-clustered인덱스 만들기**
`CREATED INDEX index_name ON table_name (column_name)`

**Composite인덱스 만들기**
 여러 개의 컬럼에 대해서 컴포싯인덱스를 만들수있다.
 ` CREATE INDEX index_name ON table_name(column_name1, column2,...)`

**인덱스 확인하기**
`SHOW INDEX FROM  table_name`;

**인덱스 삭제하기**
`DROP INDEX index_name ON table_name;`
 항상  인덱스 이름을  알고있어야한다는점, 위에 인덱스 확인하기 명령어로 해당 인덱스이름을 알수있다.

**인덱스 사용하기**
SELECT문으로  똑같이 조회를 하면  DBMS가 알아서  인덱스를 사용할 수 있는 쿼리들에 대해 인덱스 사용을 해준다.

! 인덱스는 조회를 효율적이게 할 수 있게 해주는 반면, 나머지 연산들: 삽입, 업데이트 , 삭제를 오히려 비효율적이게 만든다.
! 조회에 거의 사용되지 않는 컬럼에 인덱스는 용량낭비
! 삽입,업데이트,삭제  연산, 이게 자주 일어나는 컬럼에 대해서 인덱스를 만든다면 오히려 데이터 베이스 자체가 느려지는 효과가 생긴다.
