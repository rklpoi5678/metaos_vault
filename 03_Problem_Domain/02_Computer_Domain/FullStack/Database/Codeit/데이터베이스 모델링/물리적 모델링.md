## 물리적 모델링 범위
실제로 만들 데이터베이스에 가장 가깝게 모델을 만드는 과정이다.
어떤 DBMS를 사용할건지, 보안은  어떻게 해결할 건지, 마스터 권한은 누구에게 있고,  데이터베이스를 몇개로 나눠서 사용할 건지, 캐시는 어떻게 사용할건지.. 테이블 구조와 관계와는 동떡어져있다고 느낄만한 내용을 모두 게획해야 합니다..
데이터베이스 뿐만 아니라 소프트웨어 요소들이 이루는 하나의 시스템을  어떻게 디자인할 건지와도 굉장히 밀접해있다.

## 네이밍
캐시 무효화와 네이밍이 어렵다.

**단수/복수 정하기**
단수는 일관성이있다.
복수를 쓰는사람은 테이블 하나가 아니라 여러 개체의 데이터를 저장하고 있다고해서 복수형을 쓰는 사람이있다.

컬럼이름은 일반적으로  단수를 사용한다.

**대문자/띄어쓰기 정하기**
user_id
UserId
userId 세가지 모두 사용해도되긴합니다. 컨벤션

**줄임말 사용하기**

**네이밍**
어떤 규칙을 저앟는지보다 정해진 규칙을 잘 따르는게 중요하다.
처음에 규칙을 최대한 명확하겍 정하고, 이 규칙을 잘지키는것 무엇보다 중요하다.

## 데이터  타입
- 각  컬럼이 "어떤" 데이터를 저장하는지에 대한 내용
- 데이터베이스의 가장 기본적인 제약 사항 (데이터 정확성을 지켜주는 역활을 한다.)
- 데이터 타입이 일괁되지 못하면 데이터 연산을 할수있는 명령어를 입력하기 어렵다
똑같은 데이터를  저장하되, 용량은 가장 작게 사용하는 게 좋다.  (데이터베이스 용량이 클수록 느려진다.)

**데이터 타입을 잘 정해야 되는 이유**
- 데이터 정확성을 지키기 위해
- 데이터베이스 연산/함수들을 제대로 활용하기 위해서
- 데이터베이스 용량을 최적화하기 위해서

## 데이터베이스 타입  정리
MySQL기준
- Numberic types(숫자형 타입)
-  Date and Time types(날짜 및 시간  타입)
- String types(문자열 타입)

1. Numeric types
	1. TINYINT
	2. SMALLINT
	3. MEDIMINT
	4. BIGINT
	5. DECIMAL
	6. FLOAT
	7. DOUBLE
2. Date and Time Types
	1. DATE
	2. DATETIME
	3. TIMESTAMP
	4. TIME
3. String type
	1. CHAR
	2. VARCHAR
	3. TTEXT
## 제약 조건
constraint 대부분의 DBMS들은 테이블들에 제약 조건을 걸게 해주는 기능이 있다. "겹치는 값이 없어야한다. 값이 특정 범위, 길이, 또는 값이어야 한다." 이런  내용들을 미리 정해놓고, 어기는 값을 저장하려고 시도하면 자체적으로 오류를 내서 원하지 않는 값이 저장되는 걸 미리 막아준다.

제약조건은 ERM 에 표현하기  힘들기에 따로 종이나 메모, 실제로 데이터베이스에  계획된 내용을  반영할 때 SQL또는 ORM을 사용하면 된다.

## 선형 vs 이진 탐색
인덱스: 선형/이진탐색을 알아야한다.

데이터를 아무 규칙없이 정렬하면 선형탐색보다 더 좋은 규칙은 없다.ㅏ
O(N)
오름(내림)차순으로 정리하면 중간에서 크냐 작냐 찾아서 반을 버리고 또반을 나누고 책을 반접고 펴는형식으로 찾는것이다. (탐색 범위를 반씩 줄여나갈수있다.)
 O(log(N))
 원소들이 많아질수록  차이가  커진다.

## 인덱스 개념
색인,인덱스(책 가장 뒷부분에  존재하는것)
이진 탐색으로 찾을수있다(책에서는 가나다로 정렬되었기때문에)
더 빠르게  찾기위해서  특정값들의 정보를 저장해놓은것을 인덱스라고 한다.

## Clustered vs Non-Clustered 인덱스
테이블 자체를 특정 순서로 저장하는 인덱스
로우들이 email의 알파벳 순으로 정렬됨
- 조회 속도가 굉장히 빠르다
- 인덱스를 하나밖에 못 만든다.
- 언어 사전과  비슷한 개념(애초부터 알파벳순서로 책을 만들었기떄문에 한글문서로 변환하던가 다른예가 생기면 선형탐색을 해야됨)

논클러스터드는 
- 관계없이 무작위로 순서들을 정해놓기에 제한이 없다.
- 인덱스를 모든 컬럼에 대해서 만들 수 있다.
- 클러스터드 인덱스보다는 조금 느리다.
- 일반   책의 색인,또는 인덱스와 비슷한 개념