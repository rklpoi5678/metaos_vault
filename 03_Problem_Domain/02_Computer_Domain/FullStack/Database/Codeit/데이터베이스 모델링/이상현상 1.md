## 데이터베이스 이상 현상
데이터베이스에서 삽입,업데이트, 삭제를 제대로 할 수 없게 되는 경우
데이터 모델링을 제대로 하지 않았기 떄문에 발생

**삽입이상**
새로운 데이터를 자연스럽게 저장할 수 없는 경우![[Pasted image 20251001170346.png]]
**업데이트 이상**
데이터를 업데이트했을 때, 정확성을 지키기  어려워지는 경우

**삭제이상**
원하는 데이터만 자연스럽게 삭제할 수 없는 경우
구지 지워지고 싶지 않은 데이터도 같이 지워지는경우

## 정규화(Normalization)
테이블이 잘만들어졌는지 평가하고, 잘 만들지 못한 테이블을 고쳐나가는 과정
테이블 정규형이라고 불리는 형태에 부합되게 만들어나감

**정규형**
1NF,2NF,3NF ...
순서에 따라 규칙이 누적된다.
제 3정규형 까지만 해도 잘 부합된 데이터이고 그 이상은 연구할사람만

- 이상현상을 없앨수있다.
- 새로운 종류의 데이터를 추가할 때 테이블 구조 수정을 많이 하지 않아도 된다.
- 구조를 단순화해서 사용자가 더 쉽게 이해할 수 있다.

! 실제 데이터베이스에 구현하기 전에 적용하면 좋다.  최대한!

## 1정규형
모든 로우의 모든 컬럼 값들이 **나눌수없는 단일값** 이어야 한다.
![[Pasted image 20251001170817.png]]
> phone_number테이블을 따로만들어서 외래키로 연결시킨다.
> 온전히 그 단위 자체로 사용하는지, 저장하는 값들을 일부분만 사용할 수도 있는지 판단하고 그걸 바탕으로  모델링해야한다.

## 함수 종속성(Functional Dependency)
x의 값에 따라서 y의 값이 결정 될때, **y는 x에 함수 종속성이 있다고**한다.(y->x)
![[Pasted image 20251001171437.png]]
> 이메일만 알고있으면 나머지 컬럼의 3가지를 알수있다.
> name,age,gender는 email에 함수 종속성이 있다.(email -> (name,age,gender))

![[Pasted image 20251001171605.png]]
> 함수 종속성은 반드시  하나의 컬럼에만 있어야 하는것은 아니다.
> 즉 수학적으로 쌍을 나타내면 {user,product} -> score

**이행성**
![[Pasted image 20251001171740.png]]
> brand_country 는 brand함수  종속성이 있고, brand는 product에 함수종속성이있다.
> 즉 brand_country는 이행적 함수 종속성이 있다고 한다.

## Candidate Key
하나의 로우를 특정 지을수있는  속성들의 집합이다.
![[Pasted image 20251001171922.png]]
> id를 사용해도 하나의 review로우를 특정 지을 수 있다.
> candidate key 면서 primary key이다.
![[Pasted image 20251001172032.png]]
> id,user_id,product_id 가 prime attrubuite에 속한다.
> 그러면 나머지(score,description)은  none prime attrubuite에 속하는것이다.


