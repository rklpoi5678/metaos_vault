## 서버사이드 렌더링
정적 생성과 서버사이드 렌더링을 동시에 할수없다.
```js
// getStaticProps랑  같이 쓰면 안된다.
export async function getServerSideProps(context) {
	const productId = context.params["id"];
	const res = await axios.get(`/products/${productId}`)
	productId = res.data;
} catch {
	return {
		notFound: true,	
	};
}

const res = await axios.ge
```
> 상품 페이지를 접속 했을때는 새로운 상품들이 있을수있기에 서버사이드 렌더링으로 동적으로 만들어준다.

## 클라이언트에서 데이터 주고 받기
state를 어떻게 활용할건지 생각해봐야한다. 정적이든 서버사이드렌더링이든 
```js
export default function Movie({ movie, movieReviews: initalMovieReviews }) 
	const  [movieReivews, setMovieReviews] = useState(initalMovieReivews)
	...
}
```

## 렌더링 과정 살펴보기
next.js는  link가 들어오면 link에 맞는 필요한 자바스크립트 코드만 다운로드 받는다.
프리렌더링때 새로고침되면서 화면에 잠깐 깜빡이는데 , 이 타이밍에 필요한 데이터만 받아오니 빠르고 절묘하다. 그리고 받아야할 데이터도 줄어들게된다. next.js에 가장 핵심적인 기능이다.

## 정적 생성 vs SSR
홈페이지: 상품 데이터가 자주 업데이트 되지 않다고 가정, 정적 생성을 했다.
검색 페이지: 쿼리스트링 값에 따라서 다른 검색 결과를 보여 줘야 하기에 서버사이드렌더링
상품 상세 페이지: 항상 최신의 리뷰  데이터를 보여주기 위해, 서버 사이드렌더링
설정 페이지: next.js 에서는 특별한 경우가 아니라면 되도록 정적 생성으로 구현할 것을 권장한다. 리퀘스트가 들어올때 마다 매번 렌더링을 하는 것보다 미리 렌더링을 해서 저장해 둔 것을 보내 주는 게 훨씬 빠르기 때문이다.

### **서버사이드 렌더링을 고려하면  좋은 경우**
- 항상 최신의 데이터
- 데이터가 자주 바뀌는경우
- 리퀘스트의 데이터를 사용해야 하는 경우  (헤더  ,  쿼리스트링, 쿠기 등)
그 외에 특별한 이유가 없다면 되도록 정적 생성을 하는 것을  권장

## 프리 렌더링 정리
웹 브라우저가 페이지를 로딩하기 이전에 렌더링하는 것을 말한다. 정적 생성과 서버 사이드 렌더링으로 나뉜다. Next.js에서는 기본적으로 모든 페이지를 정적 생성한다.

## 정적 생성
프로젝트를 빌드하는 시점에 미리 HTML을 렌더링하는걸 말한다. 기본적으로 Next.js에서는 모든 페이지를 정적생성한다.

**getStaticProps 함수**
```js
export default function getStaticProps() {
	const res = await axios('/products/');
	const products = res.data

	return (
		props: {
			products,	
		},
	);
}

export default function Home ({ products })  {
	return (
		<ProductList products={products} />	
	)
}
```

**getStaticPaths 함수**
다이나믹 라우팅을 하는 페이지를 정적 생성을  할 때에는 어떤 페이지를 정적 생성할지 지정해줘야 한다. getStaticPahts()라는 함수를 구현하고 export해서 정해줄수있다.

이 함수는 리턴값으로 객체를 리턴한다. paths라는 배열에서 각 페이지에 해당하는 정보를 넘겨줄수있다.
```js
{ params: {id: '1' }}
```
fallback이라는 속성을 사용해서 정적 생성되지 않은 페이지를 처리해 줄것인지 정할수있다.
```js
export async function getStaticPaths() {
	return (
		paths: [
			{params: { id: '1'}},	
			{params: { id: '2'}},	
		],	
		fallback: true,
	);
}
```
context 파라미를 사용해서 필요한 Params(Context.params)값이나 쿼리스트링 값을 참조할 수 있었다.  fallback을 true로 했다면 적절한 예외처리를 해야하낟. 데이터를 찾을 수 없을때 404페이지로 이동시킬 수 있다.

```js
export async function getStaticProps(context) {
	const productId  = context.params["id"];
	
	let product;
	
	try {
		const res  = await axios('/products/${productId}');	
		product = res.data;
	} catch {
		return {
			notFound: true,	
		};	
	}

	return {
		props: {
			product,	
		},	
	};
}
```
```js
// getStaticProps를 실행하는 동안 보여 줄 로딩 페이지를 구현
// 페이지  컴포넌트에서 필요한 데이터가 존재하지 않을 때를 처리
export default function  Product({ product }) {
	if (!product) {
		return <>로딩중 ...</>	
	}
	return <>상품 이름: {product.name}</>;
}
```

## 서버사이드 렌더링(Server-side Rendering)
리퀘스트가 도착할 때마다 페이지를 렌더링해서 보내주는 방식이다.
getServerSideProps로 함수를 구현하고, export하면된다. 리턴 값으로는 객체를 리턴한다.
```js
export async function getServerSideProps() {
	const res = await axios('/products/')'
	const products = res.data;

	return (
		props:  {
			products,	
		}	
	)
}

export default function Home ({ products }) {
	return (
		<ProductList products={products} />	
	)
}
```

## APP Router소개
next.js 13.4이후 버전부터 소개
/pages 폴더가 아닌 /app폴더에 페이지 컴포넌트들을 추가한다는 것이다.
기본적으로 리액트 서버 컴포넌트이다. 서버에서만 렌더링되는 컴포넌트이다.

## React Server Components(RSC)란??
가장 큰 차이란 데이터를 가져오는 방식에서의 차이이다.
async/await함수로 만들 수 있고, 함수 최상위(top-level)에서 await로 데이터를  가져올 수있다.
서버에서 모든 데이터를 가져온 다음 렌더링까지 해서 보내주기에 서버와 클라이언트가 여러 번 리퀘스트를 주고받을 때보다 빠르게 페이지를 보여줄 수 있다.
``` jsx
async function getData() {
	const res = await fetch('https://api.example.com/...');
	return res.json();
}

export default async function Page() {
	const data = await getData();
	
	return <main>...</main>;
}
```
새롭게 시작하는 프로젝트에서는 App Router사용을 권장한다.
정적 생성, 서버사이드렌더링, 이제 서버 컴포넌트까지 활용해서 최적화된 웹사이트를 만들 수 있게 되었다.