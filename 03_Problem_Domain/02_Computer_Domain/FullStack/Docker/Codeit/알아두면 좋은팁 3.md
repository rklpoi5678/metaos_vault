## 개발 생산성

**개발 생산성** 관점에서 최적화할 수 있는 부분은 레이어 캐시 최적화입니다.이미지를 빌드하는 과정은 이미지를 구성하는 여러 개의 레이어를 각각 생성하는 과정과 같아요. 빌드 과정이 반복된다면 변경사항이 없는 레이어는 이전에 만들어 둔 캐시를 사용해서 중복 작업을 최소화해요.

그런데 레이어가 수정되어 캐시가 무효화되면 이어지는 모든 레이어의 캐시도 무효화돼요. 마치 도미노처럼요. 그래서 레이어를 만드는 작업이 크고 오래 걸리는 레이어라면 다른 레이어에 의한 캐시가 무효화되는 것을 최대한 줄이는 게 이미지 빌드 시간을 줄여 줄 겁니다. 그리고 이는 곧 개발 생산성으로 이어질 수 있죠.

레이어의 캐시를 최대한 활용하기 위해선 변경이 잦은 레이어를 Dockerfile 후반부에 배치하고, 변경이 적고 작업 크기가 무거운 레이어는 초반부에 배치하는 것이 좋습니다.

```Dockerfile
...
COPY . /apps/mbti
WORKDIR /apps/mbti
RUN npm ci \
   && npm run build
...
# 우리의 애플리케이션은 의존성을 설치(`npm ci`)하는데 비교적 시간이 많이 소요되는 편이지만 변경될 가능성이 많지 않습니다. 반대로 소스코드는 수정이 잦은 편이죠. 지금 상태라면 의존성이 변경되지 않아도 소스코드만 변경되면 의존성 설치까지 계속 반복해서 작업하게 됩니다.

##이런 경우 두 작업을 다음과 같이 분리해서 작성할 수 있습니다.

...
WORKDIR /apps/mbti
# 의존성 설치
COPY package.json /apps/mbti/package.json
COPY package.lock.json /apps/mbti/package.lock.json
RUN npm ci
# 소스코드 복사 및 빌드
COPY . /apps/mbti
RUN npm run build
...
# 이렇게 작성하면 의존성 설치와 관련된 레이어와 소스코드 빌드와 관련된 레이어가 분리되면서 소스코드 변경에 의한 의존성 설치 작업의 반복을 줄일 수 있습니다.

```

## 성능
이미지의 크기를 줄이기 위해 두 가지 방법을 고려해 볼 수 있는데요. 첫 번째 방법은 크기가 **작은 베이스 이미지**
![vo7av4a8h-image.png](https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=10951&version=1&directory=/vo7av4a8h-image.png&name=vo7av4a8h-image.png)
![[Pasted image 20250929004403.png]]
은 버전의 `node` 이미지라도 더 작은 크기의 이미지를 별도로 제공하는 경우가 많습니다. 보통 태그에 `slim` 키워드를 붙이는 경우가 많아요. 개발 단계에서는 `node` 모듈뿐만 아니라 `curl` 과 같이 테스트를 위한 모듈들도 같이 사용할 가능성이 높기 때문에 한 이미지에 같이 포함되는 것이 편리합니다. 따라서 이미지의 크기가 커집니다.

반면에 실제 프로덕션 단계에서는 `node`와 관련된 꼭 필요한 모듈만 포함합니다. 이에 따라 크기를 더 작게 할 수 있는 것이죠.우리의 베이스 이미지의 태그를 `ARG` 를 통해 동적으로 할당할 수 있게 만들고, 이미지 빌드 환경에 따라 더 작은 크기의 베이스 이미지를 선택하면, 자연스럽게 우리의 이미지도 작아질 수 있습니다.

두 번째 방법은 **멀티 스테이지 빌드**를 통해 애플리케이션 실행에 반드시 필요한 파일만 이미지에 포함시키는 것입니다. 멀티스테이지 빌드란 하나의 Dockerfile에서 이미지를 빌드하는 과정을 여러 개로 분리해 정의하는 방식입니다.

우리가 다루었던 애플리케이션도 TypeScript 모듈은 빌드할 때만 필요하고 실제 실행할 때는 필요하지 않은 대표적인 모듈이죠. 따라서 멀티스테이지를 활용해 최종 이미지에는 필수 모듈만 포함되도록 할 수 있습니다.

스테이지를 분리하려면 `FROM` 명령어 뒤에 `AS` 옵션으로 스테이지 이름을 정의하면 됩니다. 그리고 새로운 스테이지에서 해당 스테이지의 파일을 `COPY --from` 명령어를 통해 복사할 수 있어요

```dockerfile
# 빌드만 진행하는 스테이지
ARG NODE_VERSION
FROM node:${NODE_VERSION} AS build
COPY . /apps/mbti
WORKDIR /apps/mbti
RUN npm ci \
   && npm run build

# 빌드된 파일을 실행하는 스테이지
FROM node:${NODE_VERSION}-slim
COPY --from=build /apps/mbti/.next /apps/mbti/.next
COPY --from=build /apps/mbti/public /apps/mbti/public
COPY --from=build /apps/mbti/package.json /apps/mbti/package.json
COPY --from=build /apps/mbti/package-lock.json /apps/mbti/package-lock.json
WORKDIR /apps/mbti
# 실행에 필요한 의존성만 설치
RUN npm ci --only=prod
ENV PORT="3000" \
    DB_HOST="localhost" \
    DB_PORT="3306" \
    DB_NAME="mbti" \
    DB_USERNAME="mbti" \
    DB_PASSWORD="mbti1234"
ENTRYPOINT ["sh", "-c", "npm run start"]

## 위의 예시에서는 빌드된 파일(`.next`)과 실행이 꼭 필요한 파일만 복사했습니다. 그리고 의존성은 `npm ci --only=prod` 명령어를 통해 반드시 필요한 것만 설치했습니다.
```

```비교
# 멀티 스테이지 빌드를 적용한 것과 그렇지 않은 이미지를 각각 빌드해서 크기를 비교해 볼게요.
➜ docker image ls                                                     
REPOSITORY   TAG            IMAGE ID       CREATED         SIZE
mbti         multi-stage    2315b7fb98bc   5 seconds ago   919MB
mbti         normal         8a27e7df991a   6 minutes ago   1.91GB

```

## 가용성
도커 엔진이 실행되는 운영체제의 아키텍처를 플랫폼이라고 합니다. 보통 Windows와 Intel Chip macOS, 일반적인 Linux는 **linux/amd64** 아키텍처를 따르고, Apple Silicon 기반의 macOS는 **linux/arm64** 아키텍처를 따릅니다

!! Windows와 macOS는 linux가 아닌데 linux/* 아키텍처를 가진다고 표현한 이유는, 이전에 배운 것처럼 리눅스가 아닌 운영체제에서는 도커 엔진이 VM에서 동작하기 때문이며, 이 VM이 리눅스 운영체제를 가집니다.

아키텍처마다 파일 저장 구조가 달라 호환성이 깨질 수 있습니다. 따라서 이미지를 빌드할 때 `--platform` 옵션을 활용해 다양한 플랫폼을 지원하는 것을 고려하는 것이 좋습니다.

```docker
docker image build \
    --platform=linux/amd64,linux/arm64,linux/arm/v7 \
    ...

```

가용성을 높이는 두 번째 방법은 풍부한 명세를 활용하는 것입니다. 아무리 잘 만든 이미지라도 이미지에 대한 설명이 부족하다면, 쉽게 사용할 수 없습니다.
따라서 이미지를 사용하는 방법 등에 대해 문서로 잘 정리하는 것이 중요합니다. DockerHub에서 Overview 탭처럼 말이죠.

이뿐만 아니라 Dockerfile의 명령어를 통해서도 명세를 풍부하게 할 수 있습니다. Dockerfile의 명령어 중 일부는 아무런 기능이 없는 것처럼 보이는 경우가 있습니다. 대표적으로 `EXPOSE`, `LABEL`, `MAINTAINER` 와 같은 명령어는 기능적인 역할은 없습니다.

따라서 이러한 명령어는 누락해도 오류는 없습니다. 하지만 이미지의 정보로서 유의미하며 표준으로 관리되는 정보입니다. 구태여 별도의 문서로 일일이 설명하지 않아도 확인할 수 있는 정보죠.

지금까지 **개발 생산성**, **성능**, **가용성** 측면에서 더 좋은 이미지를 만들기 위한 팁에 대해 알아보았습니다.

지금 당장 적용하지 못해도 괜찮습니다. 먼저 Docker에 충분히 익숙해지세요. 그다음에 이 레슨에서 배운 것들을 활용해 보기 바랍니다.