## Refesh 토큰
 만료시간이 길면 악의적인 사용자가 가로채버린다면 특정 권한을 갖는 유저 행세를 할수있게된다.
 access 토큰이 만료됐을 때, 이메일 비번을 사용하지 않고 access 토큰을 새롭게 발급받는데 사용되는 토큰이다.

서버는 클라이언트에서 access와 refresh 두가지 토큰을 보내줄 수 있다.
Access token  - 소유자가 특정 권한을 가질 수 있게
Refresh token = 이메일과 비번을 사용하지 않고 new Access token을 발급받을 수 있게 하는  토큰

만료시 클라이언트는 access 토큰을 새롭게 발급받는 URL에  새로운 GET 리퀘스트를 보낸다. 이때 body에 refresh 토큰을 함께 보낸다. 서버는 해당 토큰이 유효한 지  확인후 새로운 엑세스 토큰을 발급한다. 리스폰스로 돌려준다.

access  token - 10min -> refresh token - 24hour이렇게 된다. 리프레쉬 토큰이 더 짧다는 특성이다. 이메일 과 비번라는 개인 정보를 리퀘스트로 최대한 적은 회수 보내도 되기에 더 위험 부담을 줄일수있다.

**Access와 Refresh 두 토큰 모두 탈취되더라도 Refresh 토큰을 비활성화 시켜, Access 토큰의 짧은 유효기간 동안만 탈취된 토큰을 사용가능하도록 하면, 탈취 피해를 줄일 수 있습니다.**

## JWT (JSON Web Token)
JSON 형식으로 인코딩한 토큰이다.
![[Pasted image 20251004185031.png]]
> 점을  기준으로 3부분으로 나뉜다. base64인코딩 - 디코딩  결과사진

헤더 : 토큰 자체에 대한 데이터 저장 (암호화에 사용된 알고리즘 토큰 형식이 저장됨)
페이로드:
	토큰이 실질적으로 저장하려는 정보, 
	저장하고 싶은 데이터 종류의 제한은 없음
	최대한 짧게 꼭 필요한 내용만 간결하게
	공식 이름 최대한 활용(exp,iat,jti...)
		 - exp: 만료시간
		-  iat: 발급시간
		-  jti: (JSON TOKEN ID): 토큰 고유값
		-  토큰이 인증하려는 유저
시그니쳐:
	토큰을 믿을 수 있는지 확인하기 위한 데이터 저장
	![[Pasted image 20251004185502.png]]
		헤더의 알고리즘으로 암호화해서 나온값을 사용한다.
		확인도 해당 알고리즘을 만들어서 서로 똑같은지 비교하면된다. 그러면 해당키는 시크릿 키를 가지고 발행한 것이라는 것을 알수있다.

		다른면 누군가 토큰을 임의로 조작했다는 걸 알수있다 (누군가 페이로드 헤더 수정시)
			리퀘스트의 인증을 무시하면된다.
			중간에 탈취해도 유저행세를 할수있지만 만료시간을 늦추거나 할수는없게된다.

주의점
- 헤더와 페이로드 부분은 단순히 인코딩된 거기 때문에 아무나 볼수있다.
- 보안에 민감한 내용은 최대한 넣지마십시오

## 세션 vs 토큰 기반 인증
1. 효율성
	1. 로그인한 유저가 많거나, 특정 시간에 몰린다면
	2. 서버의 리퀘스트 처리 속도가 느려질수있음
	3. 토큰 기반 인증은 어딘가 저장된 데이터 비교가 아니라 토큰 자체 내용을 해석하기만 하면된다.
	4. 효율적임
2. 유연성
	1. 토큰  발행법, 시크릿키가 존재 -> 발행을 한 곳과 확인을 하는 곳이 달라도된다.
	2. 요즘 코고 복잡한 웹 들이 더 작은 내용을 담당하는 작은 부분들로 나눠서 개발하는 경우가 많다. 이럴 때 토큰을 사용하는게 훨씬 더 유연하다.
3. RESTful API
	1. server가 state정보를 (유저가 로그인했는지 안했는지 저장시)  stateful하다 표현한다.
	2. REST에 부함하기 위해 서버가 상태 정보를 저장하지 않는 stateless한 특성이 있어야한다.
	3. 서버는 클라이언트에서 보내는  정보만으로 충분히 상태를 파악할 수 있어야한다.
	4. RESTful한 API서버를 만들고싶다면 세션 기반 인증보다 토큰 기반 인증이 더 어울린다.
4. 무효화
	1. 세션은 특정 세션을 손쉽게 무효화 시킬수있음
	2. 토큰은 따로 서버가 상태 정보를 저장하지 않기에  특정 토큰을 무효화하는 게 더 복잡하다.
	3. 이건 문제로 이어지는것이 금융 서비스에서 누군가 유저 토큰을 가로챘는데 이걸 바로 무효화할 수 없으면 돈을 뺏기는 문제가 발생
	4. 세션 기반 인증을 사용하면 한가지 안전장치를  더 손쉽게 사용할 수 있다.

## 인가: Authorization
리퀘스트가  어떤  권한이 있는지 판단
![[Pasted image 20251004190455.png]]
> 어떤 유저인지 확인(인증) ->  유저가 관리자 또는 게시글 작성자인지 확인(인가)
> 일반적으로 인증이먼저 그다음 인가가 뒤따른다.

![[Pasted image 20251004190626.png]]
>  간단한 코드만으로 인가를 구현할수있다.
>  또한 인증과 인가를 알면 기획내용을 더 잘알수있다.

##  Authorization 헤더를 인증에 사용하는 이유
20여 전에는 두단어를 구별하지 않거나, 인가를 위해 당연히 인증 정보를 사용해야한다고 생각 추측
즉, 잘못지음
-> 헤더는  인가가 아닌 인증을 위한 헤더라는 점을 이해하면된다.