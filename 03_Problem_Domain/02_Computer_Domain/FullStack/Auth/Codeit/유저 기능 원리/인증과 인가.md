## 유저 기능이란?
수많은 사이트에 유저란 기능은 꼭필요하다.
유저 1이 보낸 리퀘스트 : 인증(Authentication)
해당 코멘트를 지울 권한이  없음 : 인가 (Authorization)
> 모든 것을  묶어서 유저기능이라고 한다.

특정 프레임워크에 의존하지 않고 유저 기능 원리를 안다.

## 인증 : 어텐틱케이션
유저를 나타내는  클래스(모델을 만든다)
-  요즘 트렌드는 id대신 email을 아이디로 사용한다. (복구가 편함)
- 아이디는 중복이 안되어야하며, 비밀번호는 암호화해서 보낸다.

회원가입 ->> 유저 데이터를 저장시켜주면된다.
post -> 서버에서는 인증정보에 기본validate를 검사

실패 400 Bad Request를 보내면되고
성공 200 ok 와 문자열형식의(?) 인증서를  같이 보내면된다.

인증서는 로그인한 유저가 누군인지 알수있는 인증서같은것이다.
로그인 상태를 유지할수있게 할수있다.
모두 다른 인증서가 있으면 누가 누군지 알수있게되어 각자다른 http메서드를 사용할수있다.
인증서에는 만료기간이 있다.

thinkpoint: 클라이언트와 서버단에서 어떤 인증서를 주고받을지 이런것들이 있다. 이런것들에 따라 인증법, 분류법이 달라질수있다.

## 쿠키 인증
쿠키 : 서버 리스폰스나 , 클라이언트 코드에 따라 브라우저에 저장되는 작은 단위의 문자열 파일들
```cookie
certificate(이름)=1a2b3c(값); expires=Web, 20 Apr 2022 06:17:36 GMT(속성); SameSite=Lax(속성); Secure(속성)
# 이름과 값쌍 , 속성들은 세미콜론등으로 구별되어있다.
# 인증서로 사용할수있는 어떤것을 쿠키로 사용할수있다는것
```
클라이언트에서 쿠키헤더를 만들어 보내고 서버에서는 쿠키헤더로 어떤 유저가 보낸것인지 알아낼수있다.
![[Pasted image 20251004175204.png]]
같은 도메인 상에서는 쿠키가 공유될수있다.

쿠키 저장과  전송
은 웹 브라이저에서 자동으로 해준다.![[Pasted image 20251004175240.png]]
조금더 편리하게 인증을 구현가능하게 한다.

이러한 방식으로 인증하는것을 **쿠키 인증** 이라고 한다.

## 쿠키 보안
검색 기록, 쇼핑카트, 한번 설정한 라이트와 다크테마 유지를 쿠키로 할수있다.
하지만 사용자가 아닌 다른  사람이 쿠키를 가로첸다면 -> 보안문제
보안 문제를 줄일 수 있는 설정을 알아본다.

(리스폰스 쿠키 설정 예시)
![[Pasted image 20251004175413.png]]
**Secure**
HTTP보다 보안에 강한 HTTPS를 사용할 때만 클라이언트에서 서버로 쿠키가 보내진다.
HTTPS를 사용하면 항상 req,res가 암호화되기에 누군가 중간에 리퀘스트를 가로챘을 때 정보 유출을 줄일수있다.
```http
Set-Cookie: cookie_name=cokkie_value; Secure;
```
**HttpOnly**
클라이언트가 js코드로 해당 쿠키에 접근할수 없 게 된다.
그냥 쿠키를  설정한 웹에 리퀘스트로 보낼 수 만있게된다.
코드로 쿠키에 접근할수 없으면, 악의적 클라이너트가 개인 정보에 직접 접근하는  걸 막을수있다.
다만 코드로 접근하고싶을수 있으니, 필요에 따라 설정한다.
```http
Set-Cookie: cookie_name=cookie_value; Secure; HttpOnly;
```
**SameSite**
Cross site request forgery의 약자(CSRF  or XSRF)라는 공격을 예방할 수 있는 설정이다.
간단히 일반A 악의적 웹B가 있을때, B 웹 브라우저에  저장된 쿠키를 가지고 사이트 A 서버로 리퀘스트를  보내는 공격이다.

samesite 를 Strict로 하면 다른 도메인에서 req를 보낼 때 쿠키가 가는 걸 아예 방지할수있다.
req를 보내느 클라이언트와  이걸 받는 서버의 도메인이 같은 때만 쿠기가 간다.
changeyourpaw.com 이란 페이지에서 facebook.com으로 req를 보낸다면 쿠키가 안간다.

다만 인증 정보처럼 민감한 정보가 아닐때는 과한 조치일수있다. 예를들어 친구가 메시지로 보낸 링크로 페이지를 방문할때 쿠키가 가지 않아 다시 로그인해야하는 경우가 생길수있는데
이때 사용하는 설정이 **Lax**(느슨한 이라는뜻)

내 사이트에 링크를 통해서 유저가 **직접** 페이스북 페이지를 방문시 쿠키가 보내지는것 반대의 경우에는 안되고

samesite을 none으로 하면 아무런 제한 없이 브라우저에서 보내는 모든 req에 쿠키가 붙어서(껌딱지) 간다. 그래서 추가로 항상 Secure설정을 추가해줘야한다. 추가하지 않으면 특정 브라우저들은 보안이 취약하다고 판단하고 쿠키를 저장하지않는다.
```http
Set-Cookie: cookie_name=cookie_value; Secure; HttpOnly; SameSite=Lax;
```

## Authorization 헤더 인증
리퀘스트에 Authorization헤더를 추가 하고 뒤에 인증서를 붙여준다.(브라우저에서 자동으로 해주지않고 자바스크립트 코드로 개발자가 붙여줘야한다.)
```http
DELETE http://example.com/comments/1
Authorization: 1a2b3c
```
서버에서는 이 헤더의 인증서를 보고 누가 보낸건지 알수있다.

이 헤더인증의 장점
- 리퀘스트에 인증서를 붙일지 안 붙일지 선택 가능하다.
- 서로 다른 루트 도메인 사이 인증 가능
유의점
- 비밀번호 같이 민감한 정보는 쿠키나 로컬 스토리지에 절대 저장하지 않는다.

[[인증과 인가 2]]