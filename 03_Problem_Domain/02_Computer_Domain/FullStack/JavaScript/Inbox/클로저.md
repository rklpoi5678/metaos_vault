## 핵심
어휘적 환경 기억(Lexical Environment): 함수가 생성될때 주변 스코프의 변수, 함수 선언등의 정보를 포함하는 환경에  대한 참조

외부 함수 실행 종료후 변수 접근: 함수의 실행이 끝날때 메모리에서 사라져야하지만, 클로저로 인해 내부 함수는 이 변수에 계속 접근

모든 함수는 클로저: 모든 함수는 생성될 때마다 자연스럽게 클로저가 된다.

## 활용
데이터 은닉:  외부에 노출하고 싶지않은(Private) 변수를 클로저로 숨길수있다.
```js
function createCounter() {
	let counter = 0 // 프라이빗 변수
	return (
		increment: function() => {
			counter ++;	
		},
		getCount: function () => {
			return counter;	
		},
	);
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount());
```

## 리액트에서 클로저
```jsx
// useState
const Counter = () => {
	const [couter, setCounter] =  useState(0);
	
	const handleClick = () => {
		// setCounter가 호출될때, 이 handleClick 클로저는 count의 현재 값을 기억한다.(클로저 위 자바스크립트 코드 참조)
		setCounter++;	
	}
	
	return (
		<button onClick={handleClick}>
			클릭 횟수: {couter}	
		</button>
	);
}
```

useEffect와 비동기 처리: 마운트 시점의  상태나 프롭스 값을 기억하고 있다.
``` jsx
useEffect(() => {
	// 이 콜백 함수는 마운트될때 count값을 기억
	// 의존성 배열이 비어있으므로, count가 업데이트되어도 이 함수는 다시 생성되지 않음
},[])

// 클로저를 이용한 js코드

// 이전 상태를 저장하기 위함
let prevDependenncies = null;

/**
*  로직 부분
*  useEffect(() => {
*  //callback부분 흉내 
  }, [// dependencies부분 흉내]) 
*/

// useEffect의 핵심 원리를 흉내 낸 함수
function useEffect_vaillaJS(callback, dependencies) {
	// 컴포넌트가 처음 마운트될 때 (의존성 배열이 null인 경우)	
	// 의존성배열 []
	if (prevDependencies === null) {
		callback(); //파라미터로 받은 콜백함수 실행
	} else {
		// 의존성 "배열"에 변경이 있는지 확인
		/** @type {Boolen} */
		const hasChanged = dependencies.some(
			(dep, index) => dep !== prevDependencies[index];
		);	
	};
	
	// 변경이 있다면 콜백 실행
	if (hasChanged) {
		callback();	
	}
	
	// 다음 렌더링을 위해 현재 의존성 배열을 저장
	prevDependencies = dependencies;
}

// 컴포넌트 렌더링을 흉내냄
function renderComponent(count) {
	console.log("렌더링 발생 현재 count",count)

	// useEffect를 흉내 내서 count가 바뀔 떄만 특정 로직 변경
	useEffect_vanillaJS(() => {
		console.log("useEffect 내부 실행 count가 변경됨", count)	
	}, [count])
}

// --- 시뮬레이션 시작 ---

// 1. 초기 렌더링
renderComponent(0);
// 출력:
// 렌더링 발생 현재 count 0
// useEffect 내부 실행 count가 변경됨 0

// 2. 상태(count)가 바뀌지 않은 재렌더링
renderComponent(0);
// 출력:
// 렌더링 발생 현재 count: 0
// (useEffect 내부는 실행되지 않음)

// 3. 상태(count)가 바뀐 재렌더링
renderComponent(1);
// 출력:
// 렌더링 발생 (현재 count: 1)
// useEffect 내부 실행 (count가 변경됨: 1)
// hasChange 실행이됨

```
> 의존성 배열에 count를 포함시키거나 함수형으로 업데이트 (setCount(prevCount => prevCount + 1))로 최신상태를 유지할수있다.

## 자바  vs 리액트 클로저의 관계
리액트는 자바스크립트의 클로저 원리를 그대로 따른다. 리액트의 컴포넌트 3가지 상태과정에서 클로저가 자연스럽게 발생한다.
오래된 상태(Stale) 문제를 해겨하고 훅을 더 효과적으로 사용한다.