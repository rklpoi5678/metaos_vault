## Intersection하면 합쳐지는 이유
**Structural Subtyping**: 타입스크립트는  해당 규칙을  따른다. 구조가 같으면 같은  타입이라고 판단한다.
```ts
interface A {
	a: string
}

interface B {
	b: string
}

function printA(arg: A) {
	console.log(arg.a);
}

// 객체 모두 a라는 프로퍼티가 있기에 타입A로 판단
const x = { a: 'codeit' };
const y = { b: 42 }; 
const z = { a: 'codeit', b: 42 }; 
const w = { a: 'codeit', b: 42, c: true }; 

printA(x); 
printA(y); // 잘못된 타입 
printA(z); 
printA(w);
```
> 같은 모양이 있으면 같은 타입이라고 판단한다![[Pasted image 20250908112103.png]]
> ![[Pasted image 20250908112118.png]]

## Union타입 살펴보기
"a타입 이거나 b타입이다"
`{a: 'codeit'`과 `{b: 42}`는 물론이고 `{a:'codeit', b:42}`도  타입`a|b`라고 사용할 수 있다.![[Pasted image 20250908112319.png]]

또한 if in문으로 프로퍼티가 존재하는지 확인, 이런식으로 타입의 범위를 좁힐수도있다. 타입스크립트에서는 이런것을 Type Narrowing이라고 표현
```ts
interface A {
  a: string;
}

interface B {
  b: number;
}

function printAUnionB(arg: A | B) {
  // 여기서는 타입 A | B

    if ('a' in arg) {
    // 여기 안에서는 타입 A
    console.log(arg.a);
  }

    if ('b' in arg) {
    // 여기 안에서는 타입 B
    console.log(arg.b); // VS Code에서 arg에 마우스를 호버해 보세요.
  }
}

const x = { a: 'codeit' };
const y = { b: 42 };
const z = { a: 'codeit', b: 42 };
const w = { a: 'codeit', b: 42, c: true };

printAUnionB(x);
printAUnionB(y);
printAUnionB(z);
printAUnionB(w);
```

**Intersection  타입 살펴보기**
![[Pasted image 20250908112539.png]]
```ts
interface A {
  a: string;
}

interface B {
  b: number;
}

function printAIntersectionB(arg: A & B) {
  console.log(arg.a);
  console.log(arg.b);
}

const x = { a: 'codeit' };
const y = { b: 42 };
const z = { a: 'codeit', b: 42 };
const w = { a: 'codeit', b: 42, c: true };

printAIntersectionB(x); // 타입 오류
printAIntersectionB(y); // 타입 오류
printAIntersectionB(z);
printAIntersectionB(w);

```