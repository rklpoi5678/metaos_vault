## 제네릭
그떄그떄마다  <>꺽쇠 안에  타입들을 넣어서 사용할수있게 한것이 제네릭이다.
```ts
// 꺽쇠안에 T같은것을 타입파라미터라고 한다. 제네릭에서는 대표적으로 T,U,V를 많이사용하면서 임의의 타입을 표현합니다. 파라미터이기에 items의 타입을  T배열로 정한것
function printArray<T>(items: T[]) {
	for(const item of items) {
		console.log(itme);	
	}
}

// printArray타입이 자동추론
printArray(shoeSizes); // Array<String>
printArray(clothingSizes); // Array<Number>
// 또한 파라미터로 넘겨주듯 직접 정할수있다.
printArray<boolean>(shoeSizes);

// interface에서도 사용가능
interface<T> extends Product {
	sizes: T[];
}

// type 별칭의 파라미터에서도 사용가능
type ClothingProduct = SizeProduct<ClothingSize>;

// 제네릭 파라미터에서도 여러개 지정가능
type Pair<T,U,V> = [T,T];
const point: Pair<number> = [1,2]

//map 에서도 제네릭을 사용하면 메서드에서도 타입을 허용할수있습니다.
const map = new Map<string, Product>();

// 타입 파라미터에서는 아무거나 정할수있지만 해당 Item이 다른곳에서 온 파라미터인지 제네릭 임의 타입 파라미터인지를 알수없어서 권장하지않음
type Pair<Item> = [Item,Item];
// 되도록 한글자만
type Pair<T> = [T,T];
// 임의 파라미터를 붙여야한다면 T 를  붙인다. 긴 코드를 만들때 이러한 접두사를 사용한다는것
type Pair<TItem> = [TItem,TItem];
```
## 예
```ts
// map에 키(K)값을 문자열로 밸류(V)값을 숫자형으로 타입을 명시해줬다.
const stock = new Map<string, number>();
stock.set('g001', 1);
stock.set('g002', 2);
console.log(stock.get('g001'));
console.log(stock.get('g002'));
```
## 알아두면 유용한 제네릭 타입들
JavaScript기능들
`querySelector()`함수
기본적으로 어떤 돔 노드가 리턴될지 모르기 때문에  `HTMLElement`라는 일반적인 타입으로 정의한다. 타입을 확신할수있는 경우에는 아래 코드처럼 직접 제네릭 타입을 정의해주면된다.
```ts
const elem = document.querySelector<HTMLInputElement>('input,username');
```
`Map`
K,V을 갖는 자료구조이다. 타입 파라미터로 키와 밸류의 타입을 정의하고 사용할 수 있다.
```ts
const productMap = new Map<string, Product>();
productMap.set(product1.id, product1);
productMap.set(product2.id, product2);
```
`Set`
배열과 비슷하지만  중복된 요소를 추가할 수 없는 ,  수학에서 집합에 해당하는 자료구조이다. 타입 파라미터로 요소의 타입을 정의하고 사용할 수 있다.
```ts
const productSet = new Set<Product>();
productSet.add(product1);
productSet.add(product2);
```

### **유용한 타입들**
키와 밸류정하기: `Record`
객체에 키와 밸류 타입을 정해놓고 싶을 때 사용한다. Map과 비슷하지만 차이점은 순수한 객체에 타입만 추가한다는 점이다.
```ts
const productMap: Recode<string, Product> = {}
productMap['c001'] =  product1;
productMap['c002'] =  product2;
```

객체 프로퍼티 고르기: `Pick`
```ts
interface Product { // type pick!
	id: string;
	name: string;  // pick!
	price: number; // pick!
	membersOnly?: boolean;
}

type ProductInfo = Pick<Product, 'name' | 'price'>;
// Pick으로 만든 타입은 아래와 같다. name프로퍼티와  price프로퍼티만 골라서 타입을 만들었다.
type ProductInfo = { // pick result
	name: string;
	price: number;
}
```

객체의 프로퍼티 생략하기: `Omit`
```ts
interface Product {
	id: string;
	name: stirng;
	price: number;
	memberOnly?: boolean;
}

type ProductInfo = Omit<Product, 'id' |  'membersOnly'>;
//omit으로 만든 타입은 아래와 같다. id와  membersOnly를 빠드리고 타입을 만들었다.

type ProductInfo = {
	name: stirng;
	price: number;
}
```

union 제거하기:`Exclude`
```ts
type Coupon = | PromotionCoupon | EmployeeCoupon | WelcomCoupon | RewardCoupon ;

// 여기서  EmployCoupon 에 해당하는 것만 제거하고 싶을 때 exclude를  사용할수있다.
type InternalCoupon = EmployeeCoupon;
type PublicCoupon = Exclude<Coupon, internalCoupon>;
// type PublicCoupon = PromotionCoupon | WelcomCoupon | RewardCoupon
; 
```

함수 파라미터 타입 가져오기: `parameters`
함수의 타입을 통해 저의할수있따. 만약 함수의 타입이 아니라, 선언된 함수라면 typeof연산자로 함수의 타입으로 만들어서  사용하면된다.
```ts
function addToCart(id: string,  quantity: number = 1): boolean {
	// ...
	return true;
}

type AddToCartParameters = Parameters<typeof addToCart>;
// type AddToCartParameters = [id:string, quantity:number | undefined]
```

함수 리턴 타입 가져오기: `ReturnType`
`Parametes`와 마찬가지로 함수의 리턴 타입을 가져옵니다.
```ts
function addToCart(id:string, quantity: number  = 1): boolean {
	//...
	return true;
}

type AddToCartReturnType = ReturnType<typeof addToCart>;
// type AddToCartReturnType = boolena
```