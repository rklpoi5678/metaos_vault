## keyof와  typeof 연산자
```ts
interface Product {
	id: string,
	name: string,
	price: nubmer,
	// salePrice: number; 이런값이 추가된다고 생각했을때
	membersOnly?: booleam;
}

// 유지보수하기 썩좋지않은 코드가 나온다.
// 이럴떄 keyof 연산자가 나온다.
//type ProductProperty = 'id' | 'name' | /*'salePrice'*/ | 'price' |  'membersOnly';

// 이럴게 keyof를 사용사면 Product의 있는 키들을 사용할수있게된다.
type ProductProperty =  keyof Product;

const productTableKeys: ProductProperty[] = ['name','price','membersOnly']

// ...

// console.log(typeof Product) //타입속성을 문자열로 출력시켜준다. object가 나온다.

// TS에서는 조금 다른데 문자열로 출력해주는것이아니라 타입스크립트 타입으로 내려준다.
// 이미 정의해둔 타입을 가져와서 타입을 정의해준다.
let product2:  typeof product;

for (let key of productTableKeys) {
	console.log(`${key} | ${product[key]}`);
}
```

## Enum과 타입 별칭

**이넘을 사용한 경우(권장)**
```ts
enum UserType {
	Admin = 'admin',
	User = 'user',
	Guest = 'guest',
}

const role = UserType.Admin;
console.log(role === UserType.Guest);
```
타입 별칭과 Union을  사용한 경우
```ts
type  UserType = 'admin' | 'user' | 'guest'

const role:  UserType = 'admin';
console.log(role ===  'guest')
```
 코드양 만 보면 타입 별칭이 훨씬 간단해보임

**JS 로 트랜스파일링  했을  때**
```js
// enum
"use  strict"
var UserType;
(function (UserType) {
	UserType["Admin"] = "admin";
	UserType["User"] = "user";
	UserType["Guest"] = "guest";
})(UserType || (UserType = {}))
const role = UserType.Admin;
console.log(role === UserType.Guest);

// 별도의 자바스크립트 객체를 만들어서 그 객체를 사용한다. UserType은 자바스크립트에서 아래와 객체이다.
{ Admin: "admin", User: "user", Guest: "guest" }
// UserType 값들을 모두 활용해서 어떤 동작을 구현하고 싶다면 이넘을 써서  Object.keys()라는 함수를 사용해 볼 수 있겠다.
console.log(Object.keys(UserType))  // ['Admin', 'User', 'Guest']
```

반면의 타입 별칭은 타입스크립트에서만 의미 이쓴ㄴ 코드이다. 이넘과 달리 트랜스컴파일을 했을때 추가로 객체 같은 걸 만들지 않고 단순히 값만  사용하는 코드가 만들어진다.
```js
"use Strict";
const role  = 'admin';
console.log(role  === 'guest');
```

결론은 되도록 이넘의 목적에 맞는 경우라면 이넘 문법을 사용하는것을 권장한다.

## interface 와 타입 별칭
2코드는 거의  같은 역할
```ts
// interface를  사용한 경우(권장)
interface Entity {
	id: string;
	createdAt: Date;
	updatedAt: Date;
}

interface User extends Entity {
	username: string;
	email: string;
}

// type alias
type Entity {
	id: string;
	createdAt: Date;
	updatedAt: Date;
}

type  User = Entity & {
	username: string;
	email:  string;
}

// interface상속과 intersection의 가장 큰 차이점은 intersection은 두 가지 이상의 타입을 한번에 합칠수있다는것이다.
```

## 어떤  것을 사용해야할까?
대부분의 경우 둘다 사용할수있지만  되도록 인터페이스의 목적에  맞는 경우라면 interface를  사용하는걸 권장한다.
```ts
// 타입  별칭은 타입에  '이름을' 정하는 문법이다. 복잡한 타입을 만들고, 그 타입을  여러 곳에서 활용할 때 사용하면 된다. 아래처럼 복잡한 타입을 만들고 여러 곳에서 재활용
type Point = [number,number];
type SearchQuery = string | string[];
type Result = SuccessResult | FailedResult;
type Coupon = 
| PromotionCoupon
| EmployeeCoupon
| WelcomCoupon
| RewardCoupon
;
```

## 정리
```ts
// 리터럴타입
const name = 'codeit'; // 'codeit' 이라는 리터럴 타입
const rank = 1; // 1 이라는 리터럴 타입
````
```ts
// 타입별칭:  복잡한 타입에 이름을 붙일때
type Point = [number, number];
type SearchQuery = string | string[];
type Result = SuccessResult | FailedResult;
type Coupon = 
  | PromotionCoupon
  | EmployeeCoupon
  | WelcomCoupon
  | RewardCoupon
  ;   

// Union: A이거나 B인 경우의 타입
ClothingProduct | ShoeProduct

// Intersection: A와 B의 성질을 모두 갖는 타입을 만들고 싶을 때
interface Entity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

type Product = Entity & {
  name: string;
  price: number;
  membersOnly?: boolean;
}

// 보통 이럴떄는 interface의 상속을 사용하는것을 권장한다.
interface Entity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface Product extends Entity {
  name: string;
  price: number;
  membersOnly?: boolean;
}

```

**keyof연산자**
객체 타입에서 프로퍼티 이름들을 모아서  Union한 타입으로 만들고 싶을 때 사용한다.
```ts
interface Product {
	id:string;
	name:string;
	price:number;
	memberOnly?: boolean;
}

type ProductProperty = keyof Product;  // 'id' | 'name'  | 'price' | 'membersOnly'

// type of 연산자
// 자바스크립트에서  코드에서 사용하면 결괏값이 문자열이지만, 타입스크립트 코드에서 쓸 때는 결과 값은 타입스크립트의 타입이다.
const product: Product = {
	id: 'c001',
	name: '코드잇 블랙 후드 집업',
	price: 12000,
	salePrice: 98000,
	membersOnly: true,
};

console.log(typeof product); // 문자열 'object' 타입스크립트에서는 타입

const product2: typeof product = { // 타입스크립티 Product타입
	id: 'g001'
	,,,
}
```