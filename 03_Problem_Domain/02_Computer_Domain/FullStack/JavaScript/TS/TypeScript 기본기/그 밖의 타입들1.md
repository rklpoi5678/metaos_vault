## 리터럴 타입
```ts
let productName1 = '코드잇 블랙 후드';
const productName2 = '코드잇 텀블러';

// literal타입 smail:95 리턴
let small = 95;
const large = 100;
// 문자열 리터럴은  문자형 숫자형 리터럴은 숫자형에 포함된다.
// 그래서 함수에 숫자형이 들어갈수있다.
// 즉 리터럴타입은 값을 타입으로 받는것이다.
/*function printSize(size: number) {
	console.log(`${size} 사이즈입니다.`);
}*/
function printSize(size: 100) {
	console.log(`${size} 사이즈입니다.`);
}
// 
// printSize(smail);
printSize(large);
```
## 타입 별칭
타입도 별칭을 지정할수있다 (type alias)
```ts
// cart타입을 바꾸면 모든곳에서 오류가 나서 수정하기 쉬워진다.
type Cart = number[];

// 함수에도 사용이 가능합니다
type CartResultCallback = (result: boolean) => void;

// 객체형태에도 사용할수있다. 하자만 되도록 interface를 사용하는것을 추천한다.
type Product = {
	id: string;
	name: string;
}

const cart: Cart = [
	'c001',
	'c002',
	'c003',
];

interface User = {
	username: string;
	email: string;
	cart: Cart;
}
```

##  Union 타입
```ts
// 상속은 똑같이만 옷 사이즈가 다름
interface ClothingProduct extends Product {
	sizes: ClothingSize[];
	color: string;
}

type ShoeSize = 220 | 225 | 230 | 235 | 240 | 245 | 250

interface ShoeProduct extends Product {
	sizes: ShoeSize[];
	//sizes: [];
	handmade: boolean;
}

// product.sizes.join 부분에서 하나만 가지져오고싶은데 오류가 나온다
// 이럴때 사용할수있는것이 유니온 타입입니다.
/*function printSizes(product: Product) {
	const availableSizes = product.sizes.join(', ');
	console.log(`구매 가능한 사이즈는 다음과 같습니다: ${availableSizes}`);
}*/

// 연산자를 활용한다.
// 한 타입이거나 또다른 타입이거나 이럴경우 사용하면 된다.
function printSizes(product: ClothingProduct | ShoeProduct) {
// 이렇게 유니온으로 묶어놓으면 공통된 타입만 사용할수있다(sizes)
	const availableSizes = product.sizes.join(', ');
	console.log(`구매 가능한 사이즈는 다음과 같습니다: ${availableSizes}`);
	
	// if in 로 검사가능
	if('color' in product) {
		console.log(`색상: ${product.color}`);
	}

	// 이렇게 if 문을 활용하면 유니온 타입에 특정부분만 처리하게 할수있다.
	if('handmade' in product) {
		console.log(
			product.handmade
				? '이 상품은 장인이 직접 만듭니다.'	
				: '이 상품은 공장에서 만들어졌습니다.'
		);
	}
}
```

## intersection 타입
타입을 합치는방법
```ts
interface Id {
	id: string;
}

interface Timestamp {
	createdAt: Date;
	updatedAt: Date;
}

// 기존에 있던 타입이랑 합치는것을 intersection이라고 한다.
type Product = Id & {
	name: string;
	price: number;
	membersOnly?: boolean;
}

// 유니온 처럼 여러번 쓸수있다.
type User = Id & Timestamp & {
	username: string;
	email: string;
}

// 또한 상속으로도 구현할수있으므로 2가지 방법이 존재하는것이다.
type Review = Id & Timestamp & {
	productId = string;
	userId: string;
	content: string;
}
```