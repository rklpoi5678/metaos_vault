## 추상화1
객체 지향 프로그래밍의 4가지 기둥
1. 추상화: 구체적인 존재를 원하는 방향으로 간략화하는 것
	1. 클래스의 프로퍼티와 메소드 이름이 직관적으로 이해하기 쉬워야한다.
	2. 실무에서는 코멘트와, 별도의 문서를 만들기도한다.
	3. 이러한 이름을 짓는것은 고역일수있을정도로(?)쉽지 않는일이다.
		1. 좋은 이름일 수록 나중에 코드를 해석할 때 드는 시간적인 비용이 줄어들기 때문이다.
	4. 보안적으로 uglify(변수명 바꾸기), minify(공백 없애기) 같은것을 하고 용량이 커지는 것을 막게할수있다 (특히 대기업 네이버라든가 js코드를 따보면 이런경우가 있죠)
2. 캡슐화: 객체의 특정 프로퍼티에 직접접근하지 못하게 만든것
```js
class User {
	constructor(email, birthdate){
		this.email = email;
		this.birthdate = birthdate;
	}
	buy(itme) {
		console.log(`${this.email} buys ${item.name}`);
	}

	//getter 메소드는 파라미터에 따로 써줄필요가없다.
	
	get email() {
		//return this._email;
		return `Email Address is ${this._email}`// 이렇게 문자열을 넣으수있다.
	}
	// 메소드가 실행되게 setter 메소드를 만든다.
	set email(address) {
		// 주소를 검증하는 코드가 들어갑니다.
		if(address.includes('@')){
			//만약 주소안에 '엣'이 포함된다면
			//이 이메일에 주소를 할당하라 (값에 대한 유효성검사)
			// 프로그래밍에서 숨기고자하는 맨앞에 언더바를 붙인다.
			// 에제 this.email에는 이상한 주소가 오는것을 방지할수있다.
			this._email = address;
		} else {
			throw new Error('Invalid email address');
		}
	}
}

const item = {
	name: '스웨터',
	price: 30000,
}

const user1 = new User('','');
user1.email = 'chris robert' // 실수로 이러한 것처럼 바로접근할려고 할때
// 위코드는 값에 대한 유효성검사에서 falsy하니 오류가난다.
user1.email = 'chris_robert@google.com'
//console.log(user1_email)
conosole.log(user1.email) //이제 언더바없이 해도된다. 임의이값이 씌워진게 아니기때문에

//처음 생성자에서 this.emali = email이 실행될때
// thso.email이 하단에 set email함수를 호출하게된다.
//그래서 _email의 값이 출력이된다._
```
1. 상속
2. 다형성
