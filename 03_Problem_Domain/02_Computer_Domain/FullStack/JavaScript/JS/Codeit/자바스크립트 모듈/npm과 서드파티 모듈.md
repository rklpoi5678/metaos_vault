## require vs import
로컬 모듈(자신이 작성한 모듈)과 서드파티 모듈을 import하는 방식이 통일되어야 하기 때문에 requre()을 import로 바꿔서 사용하는것을 추천한다.

## package.json
모듈을 패키지로 부르니까 package로 불리었다.
```json
{
	"dependencies": {
		"date-fns": "^2.30.0"
	},
	"type": "module", // commonjs문법을 이 json파일안에서 ES 모듈로사용할수있게한다.
	"scripts": {
		"start": "node main.js",
		"test" : "node test.js"
	} // npm run start, npm run test처럼 명령어로 해당 문자열에 있는내용을 실행시킬수있다.
}
```
> dependencies는 서드파티 패키지들의 목록을보여준다.
package.json 파일을 보고 main 필드에 명시된 파일에서 import를 하는것이다. 이때 main필드의 디폴트는 index.js이기 때문에 사실 이 필드가없어도 잘 작동한다.(서드 파티툴 date-fns)

## Semantic Version
```json
{
	"dependencies": {
		"date-fns": "^2.29.3" // Semantic Version(시멘틱 버전)
	},
}
```
의미론적 버전이다. X.Y.Z처럼 쪼개 봤을 때, X를 메이저 버전,Y를 마이너 버전, Z를 패치버전이라고 한다. 시멘틱 버전에서 중요한것은 패키지의 버전을 업데이트할 때 일정한 규칙이있다는것이다.

### **패치 버전(Z)**
버그 수정이나 코드의 효율성을 높이는 경우 등 기존 코드에 영향을 주지않는 변화가 있을 때 업데이트한다.(2.29.3 -> 2.29.4)
### **마이너 버전(Y)**
어떤 새로운 기능이 추가됐을 때 업데이트 한다. 새로운 버전을 사용하는 사람들은 이 함수를 사용할 수 있고 기존에 작성한 코드도 그대로 작동할 것이다.(2.29.3 -> 2.30.0)
**메이저 버전(X)**
이전 버전과 호환이 안될 때 업데이트한다. 기존에 있던 기능을 지우거나 동작방식이 완전히 바뀌어서 기존에 쓴 코드가 오류가 난다면 메이저 버전을 업데이트해야하는것
원래 사용하던 이전 버전 패키지와 비교해서 어떤 부분들이 바뀐 건지를 체크하고, 코드를 수정해야 할 가능성이 높기 때문입니다.(2.29.3 -> 3.0.0)
