리퀘스트중 기다리는동안 다른작업을 시켜서 효율적으로 일할수있게 하는것을 비동기라고 한다.
대표적으로 오래걸리는 작업을 하고 안걸리는 작업을 동시에 할때, 효율적으로 개발할수있다.
웹에서는 리퀘스트를 보내거나 사용자의 상호 작용을 기다려야 하는 일이 많다. -> 비동기 프로그래밍이 특히 많이 쓰임

## 파라미터와 아규먼트
```js
function add(x,y) {
	return x + y;
}

add(1,2);
```
x,y가 파라미터이다. 이규먼트는 실제로 전달하는 값을 의미한다. 1,2가 아규먼트이다.

## 콜백
아규먼트로 전달되는 함수를 콜백함수라고 한다.
```js
function sayHello() {
	console.log('Hello World');
}
function sayGoodbye() {
	console.log('Goodbye World');
}

function printMessage(func) {
	console.log('Printing message...');
	func()
}

printMessage(sayHello); //()를 안쓰는게 호출하는것이 아니라 아규먼트로 전달하기때문이다.
// 이런 함수를 콜백함수라고한다.

// printMessage(() => console.log('Hello World!')); 익명함수
// printMessage(sayHello, 'Bob'); 콜백은 파라미터를 받을수있다.
// printMessage((name) => console.log(`Goodbye ${name}!`), 'Bob');

```

## 콜백과 비동기 함수
JS,JS라이브러리는 **다양한 비동기 함수를 제공해 줌**
제공되는 비동기 함수에 콜백을 넘겨주기만 하면 비동기 프로그램을 구현할수있음
```js
console.log(1);

// setTimeout함수를 바동기함수라고 부른다.
// 중간에 다른 작업을 처리하다가 다시 돌아와서 마무리 하는 함수
setTimeout(() => console.log('Hello World!'),3000);

consolle.log(3);

/*
	setTimeout(callback, delay, arg0, arg1, ...)
	setTimeout(callback, delay, foo)
	함수를 호출해서는 안된다.
*/
```
![[Pasted image 20250820103151.png]]

### **비동기 함수는 이후에 있는 코드를 모두 실행하고 콜백을 실행한다**
```js
console.log('1');

setTimeout(() => console.log('2'), 0);

console.log('3');
console.log('4');
console.log('5');
console.log('6');
console.log('7');
console.log('8');
console.log('9');
console.log('10');

// 10까지 이후에 2가출력된다. 딜레이를 0으로주고 콜백을 바로실행했는데도 말이다
// 비동기 함수 이후에 있는 코드가 굉장히 오래 걸려도, 그걸 모두 실행하고 콜백실행.
```

### **실행할 콜백이 여러 개일 경우, 동기적으로 실행된다.**
```js
console.log('1');

setTimeout(() => console.log('2'), 1001);

setTimeout(() => console.log('3'), 1000);

console.log('4');

```
> 1
> 4
> 3
> 2
![[Pasted image 20250820104327.png]]> 이러한 비동기 작업들은 병렬적으로 처리되기에 충분히 효율적인 코드를 작성할수있다.

## 비동기 함수의 예시들 
```js
// ~딜레이
setTImeout(callback, delay);
```
1. setTImeout() 이전에 있는 코드 실행
2. setTimeout() 함수 실행: delay만큼 기다리는 타이머를 시작
3. seTimeout() 이후에 있는 코드실행
4. delay가 지나면 callback실행

```js
// ~조건
asyncFunction(callback, ...);
```
1. asyncFunction() 이전에 있는 코드 실행
2. asyncFunction() 함수 실행: 특정 조건이 만족되면 callback이 실행
3. asyncFunction() 이후에 있는 코드 실행
4. 특정 조건이 만족되는 시점에 callback 실행

### **setInterval()**
시간 간격을 두고 콜백을 반복적으로 실행한다.
```js
console.log('Start');

// setInterval(callback, interval): interval 단위는 밀리초이다.
setInterval(() => console.log('2초가 지났습니다'), 2000);

console.log('End');
```
> Start
> End
> 2초가 지났습니다
> 2초가 지났습니다
> 2초가 지났습니다
> 2초가 지났습니다
> ...

(콜백은 인터벌이 지난 후 처음으로 실행된다.)

멈추고 싶다면 setInterval()함수의 리턴값을 저장해놨다가 clearInterval(실행)
```js
console.log('Start');
const intervalID = setInterval(() => console.log('2초가 지났습니다'), 2000)

//7초 후에 setInterval() 해제
setTimeout(() => clearInterval(intervalID), 7000)

console.log('End')
```
> start
> End
> 2초가 지났습니다
> ...
> 

## DOM의 addEventListner()
addEventListner는 웹 페이지의 요소에 상호 작용이 있을 경우 실행할 함수를 등록한다.
```js
const btn = document.querySelector('.my-btn')

btn.addEventListener('click', () => console.log('button clicked!'))
```

## React의 useEffect() 함수
```js
function PostList() {
	// ...
	useEffect(() => console.log(`render finished!`), []);
	
	return (
		<div className="post-list">
			<div className="post-item">...</div>
			<div className="post-item">...</div>
			<div className="post-item">...</div>
			//...
		</div>
	);
}
```
> userEffect()라는 비동기함수 이 함수는 이 컴포넌트가 모두 화면에 그려지는 시점에 콜백을 실행해줌
> 먼저 화면을 그리기때문에 웹 페이지가 더 빨리 로딩되는 것처럼 보이게 할 수 있다ㅏ.

## Express의 get() 함수
```express
app.get('/hello', (req,res) => {
	res.send('Success!');
});
```
> server를 만들때 사용, 서버런 어떤 리퀘스트가 들어오면 리스폰스를 돌려주는 프로그램을 말한다. 서버는 DOM 버튼 예시와 비슷하게 리퀘스트가 언제 들어올지를 모르기 때문에 리퀘스트에 대한 처리는 비동기 형태로 한다.
> app.get()은 /hello 주소로 GET리퀘스트가 들어오면 두 번째 아규먼트인 콜백을 실행한다. 콜백은 'Success!' 라는 내용을 담고 있는 response를 보내 줍니다.

## 콜백 헬(Callback Hell)
 ```js
 //function.js는 가상의 rep를 담고있다.
 import { getEmployees, json, groupEmployees} from './functions.js'

 // res를 받으면 받은 res내용를 출력
 // 문자열로 와서 js에 원하는데이터를 얻기위한 작업을 파싱이라고한다.
 // json은 파싱하기 쉽게 만들어주는것이다.
 getEmplyees((response) => console.log(response))
 
 // 첫번째 아규먼트은 파실할 문자열
 // 두번째 문자열은 파싱이완료되고 실행할 문자열 파싱된결과를 파라미터로 받는다.
 json('response문자열이 들어감', (data) => console.log(data));
 
 groupEmployess('json파싱된 문자열',(result) => console.log(result))
 
 ---
 
 // 받은 response를 json으로 파싱한결과를 그룹임포이스에 콜백전달
 // 콜백안에 콜백이 게속하다보면 이것을 콜백헬이라고 한다. 
 // 이것은 어쩔수없는 부분이었지만 ES6이후에 나온 Promise문법으로 간단하게 표현할수있게되었다.
 getEmployes((result) +> {
	 json(response, (data) => {
		 groupEmployess(data, (result) => {
			 console.log(result);
		 })
	 })
 })
 ```

정리
```js
function printMessage(func) {
	console.log('PM');
	func();
}

function sayHello() {
	console.log('Hello World');
}

printMessage(sayHello)
```
> 콜백 파라미터없이 function키워드로 선언한 함수

```js
function printMesaage(func) {
	console.log('Printing message...')
	func();
}

printMessage(() => console.log('Hello World'));
```
> 콜백 파라미터없이 Arrow Function을 콜백으로 사용

```js
function printMessage(func, name) {
	console.log('pM');
	func(name);
}

function sayHello(name) {
	console.log(`hello ${name}`);
}

printMessage(sayHello, 'Bob');
```
```js
function printMessage(func, name) {
	console.log('PM');
	func(name)
}

printMessage(() => console.log(`Hello ${name}`, 'Bob'))
```
> 콜백 파라미터 있음

 콜백의 한계점
 ```js
 // 직업 데이터를 가져온 후 리스폰스를 파싱하고 데이터를 프로세싱 하는 예시
 getEmployee((response) => {
	 json(response, (data) => {
		 groupEmployees(data, (result) => {
			 console.log(result)
		 });
	 });
 });
 ```
 > 콜백 안에 콜백을 등록해야한다. 콜백 헬이라고 부른다.
 > 코드를 이해하기 힘들고, 디버깅이나 테스팅 같은 것을 하기도 어렵기 때문, 이 불편함을 해소하기 위해 Promise라는 것이 등장햿다.
 
 프로미스는 **비동기 코드의 결괏값을 활용해야 할 때** 특히 유용하고 이런 경우가 아니라면 여전히 콜백을 사용한다.