## 캐싱
REST  는 캐싱이 되어야된다는 전제조건이 있으며

**헤더**
- 캐싱할 자원을 판단
- 클라이언트와 서버의 자원 정보를 전달

**Cache-Control: 캐싱방식**
가장 많은 방식은  max-age=?? 값을 써서 숫자가 오를때마다 1초씩이다 60은 1분이다.
기간이 끝났을때  다시 서버로 리퀘스트를해서 보내줍니다.

**Last-Modified의 한계**
- 날짜와 시간을 기반으로 하기에,  1초보다 작은 단위의 캐싱이 불가능하다.
- 실제 자원의 변경 없이 수정된 시간만 변경된  경우에도 다른 데이터로 인식

**ETag**
entity tag
자원마다 새겨진 고유한 식별자
(사진) --------- (de6b38)
```http
Cache-Control: max-age = 60
ETag: "33a64df551425fcc55e4"

=>

GET /members/1/profile
IF-None-Match:
	"33a64df551425fcc55e4"

=>

## 캐시타임이 끝나지 않고 요청이 들어올경우
## 304상태코드를 보여주고 헤더만 보내줍니다(다시 이미지를 받지않고 헤더만 받기에 )
## 절약이 된다
304 Not Modified
Content-Type: image/png

Cache-Control: max-age = 60
ETag: "33a64df551425fcc55e4"
```
last-modified: 날짜와시간
ETag: 는 문자열이 차이라고 볼수있다.

## API버전 명시하기
엔드포인트가 추가될떄는 크게 문제될것은없다.
삭제도 크게 문제될것은없다.
둘다 API를 날리고 클라이언트에게 (추가,삭제)한다고 알리면된다

그러나 변경은 다르다.
```http
# api엔드포인트(리소스네임), http메소드가 변경될수도있다.
GET /users/1
PUT /members/1

# 주고받는 엔터티가 달라질수있다.
{
	"id": 1,
	"nickname": "James"
}
```

**작은 변경사항**
리스폰스에 바디에 구조가 변경되는사항 
- 기존의 항목을 유지한체 새로운 항목을 추가하는식으로 구현하고, 클라이언트가 기존의 항목을 사용하지않고 새로운항목을 사용할때 그떄 기존의 항목을 제거하는것

**큰 변경사항**
기존의 API엔드포인트를 바꿔야될수도있다.
단순히 리스폰스 구조를 변경하는것보다 새로운 엔드포인트로  바꾸는것이 기존개발자 클라이언트가 편하기떄문이다.
기존의 엔드포인트에서 너무 벗어나면안되기에 버저닝(Versioning) 을 사용한다.

```http
GET /members

## bad
GET /brand-new-members

## good  이렇게 버전을 붙여서  기존엔드포인트와 새로운 엔드포인트를 구분할수있다.
GET /v2/members
```

## 페이지네이션
자원의 데한 정보만 받지않고 페이징에 대한 정보도 받는다
```http
{
	"count": 52,
	"size": 10,
	"currentPag"
}
```