## 다양한 쿼리 사용하기 정리
dependant query
어떤 특정 값을 먼저 받아오거나 어떤 조건이 되었을때 쿼리 함수를 실행하려면  다음과같이 enabled옵션
```js
const { data: userInfoData } = useQuery ({
	queryKey: queryKey,
	queryFn: queryFn,
	enabled: !!username
})//
```

paginated query
placeholderData 옵션을 활용하면 , 새로운 페이지를 보여줄 때 이전의  데이터를 보여주다 새로운 데이터가 오면 자연스럽게전환
```js
const {data: postsData } =  useQuery({
	queryKey: ['posts', page],
	queryFn: () => getPosts(page, PAGE_LIMIT),
	placeholderData: keepPreviousData,
});
```

getfetchQuery 함수를 이용하면  다음 페이지의 데이터를 미리 프리페치하도록 구현가능
```js
useEffect(() => {
	if (!isPlaceholderData && postsData?.hasMord) {
		queryClient.prefetchQuery({
			queryKey: ['posts', page + 1],
			queryFn: () => getPosts(page + 1, PAGE_LIMIT),	
		});
	}
}, [isPlaceholderData, postsData, queryClient, page]);
```

infinite  query
```js
const {
 data: postsData,
 isPending,
 isError,
 hasNextPage,
 fetchNextPage,
 isFetchingNextPage,
} = useInfiniteQuery({
	queryKey: ['posts'],
	queryFn: ({ pageParam }) => getPosts(pageParam, LIMIT),
	initialPageParam: 0,
	getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => 
	lastPage.hasMord  ?  lastPageParam + 1 :  undefined,
})
```

Optimistic updates
서버가 제대로 동작할 것을 낙관적으로 기대하며, 서버로부터의 리스폰스를 기다리지 않고 유저에게 바로 피드백을 주는 방식을 말한다.
useMutation()의  onMutaion,onError,onSettled옵션을 활용해 Optimistic updates를 구현가능
```js
const likeMutation = useMutation({
  mutationFn: async ({ postId, username, userAction }) => {
    if (userAction === USER_ACTION.LIKE_POST) {
      await likePost(postId, username);
    } else {
      await unlikePost(postId, username);
    }
  },
  onMutate: async ({ postId, username, userAction }) => {
    await queryClient.cancelQueries({
      queryKey: [QUERY_KEYS.LIKE_STATUS, postId],
    });
    await queryClient.cancelQueries({
      queryKey: [QUERY_KEYS.NUM_OF_LIKES, postId],
    });

    const prevLikeStatus = queryClient.getQueryData([
      QUERY_KEYS.LIKE_STATUS,
      postId,
      username,
    ]);
    const prevLikeCount = queryClient.getQueryData([
      QUERY_KEYS.LIKE_COUNT,
      postId,
    ]);

    queryClient.setQueryData(
      [QUERY_KEYS.LIKE_STATUS, postId, username],
      () => userAction === USER_ACTION.LIKE_POST
    );
    queryClient.setQueryData([QUERY_KEYS.LIKE_COUNT, postId], (prev) => {
      userAction === USER_ACTION.LIKE_POST ? prev + 1 : prev - 1;
    });

    return { prevLikeStatus, prevLikeCount };
  },
  onError: (err, { postId, username }, context) => {
    queryClient.setQueryData(
      [QUERY_KEYS.LIKE_STATUS, postId, username],
      context.prevLikeStatus
    );
    queryClient.setQueryData(
      [QUERY_KEYS.LIKE_COUNT, postId],
      context.prevLikeCount
    );
  },
  onSettled: (data, err, { postId, username }) => {
    queryClient.invalidateQueries({
      queryKey: [QUERY_KEYS.LIKE_STATUS, postId, username],
    });
    queryClient.invalidateQueries({
      queryKey: [QUERY_KEYS.LIKE_COUNT, postId],
    });
  },
});
```

onMutate: 
 1. 데이터가 refetch로 인해 덮어씌워지는 것을 막기 위해 cancelQueries()를 실행하여, 좋아요 관련 데이터를 받아 오지않도록 쿼리를 취소해줍니다.
 2. 에러 발생시 롤백 ->  롤백용 데이터를 따로 저장
 3. 우리가 원하는 값으로 쿼리 파라미터를 미리 변경
 4. 마지막으로 롤백용 데이터를 리턴해 주면된다.

onError
1.  롤백용  데이터를 3번째 파라미터인 context로 받아 온다.  context 값으로 쿼리 데이터를 변경해준다.

onSettled
1. 에러 여부와 상관없이 백엔드 서버의  데이터를 동기화해주기 위해 좋아요 관련 데이터 쿼리를 invalidate해준다.

##  Next.js에서 ReactQuery 사용하기
서버 사이드 렌더링을 제공하는 프레임워크와 함께 사용한다. 서버에서 쿼리를 실행해 데이터를 프리패치할수있다. 이번 레스넹서는 Next.js리액트 쿼리를 사용하는 방법
```jsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

export default function App({ Component, pageProps }) {
	const [queryClient] = React.useState(
		() =>
		new QueryClient({
			defaultOptions: {
				queries: {
					// SSR에서는  staleTime을 0 이상으로 해줌으로써
					//  클라이언트 사이드에서 바로 다시 데이터를 refetch 하는 것을 피한다.
					staleTime:  60 * 1000		
				},	
			}	
		})	
	);
	
	return (
		<QueryClientProvider client={queryClient}>
			<Component { ...pageProps } />
		</QueryClientProvider>	
	);
}

```
App안에 새로운  QueryClient를 useState()를  사용해 state로 선언해줘야한다.
Next.js에서는 페이지를 이동하면 App 컴포넌트부터  새롭게 렌더링되기 때문에 쿼리 클라이언트가 매번 새롭게 생성되는 것을 막기 위해 state로 저장해준다.

Prefetch 구현하기
2가지 prefetching을 지원한다.
`initalData를 사용한 prefetching`
```js
export default function getServerSideProps() {
	const posts = await getPosts()
	return { props: { posts }}
}

function Posts(props) {
	const { data } = useQuery({
		queryKey: ['posts'],	
		queryFn: getPosts,
		initialData: props.posts,
	})
	// ...
}
```

ssr하면서 prefetch한 데이터를 useQuery의  initialData로 설정해주는 방법이다. prefetching단계에서는 리엑트 쿼리를 전혀 사용하지 않아도된다는 장점이 있다.

 getStaticProps(), getServerSideProps()는 pages폴더 안에서만 동작하기에 useQuery()를 사용하려는 컴포넌트까지 prefetch한 데이터를 props drilling으로 내려 줘야만 합니다.
initialData로  설정이 되기 때문에 새로운 데이터로 업데이트할 수 없다는 단점이 있다.

## Hydration API 사용하기
```jsx
import {  dehydrate, HydrationBoundary, QueryClient, useQuery } from '@tanstack/react-query';

export async function getStaticProps() {
	const queryClient = new useQuery()
	
	await queryClient.prefetchQuery({
		queryKey: ['posts'],
		queryFn: getPosts,	
	})
	
	return {
		props: {
			dehydratedState: dehydrate(queryClient),	
		},	
	}
}
```
> hydration nextjs의 프리렌더링은 간단히 말해서 이미 렌더링 된 HTML과리액트를 연결하는  작업을 말한다. 정적인 HTML을 리액트 코드와 연결해서 동적인 상태를 바꿔 주는 걸 수분을 보충한다는 의미로 hydrate이라고  표현합니다.

이렇게 하면 초기 설정 코드가 늘어나지만  initialData를 이용하면서 발생하는 여러 단점을 모두 해결할수있다.