## Infinite  Query
리엑트 쿼리에서 제공하는 `useInfiniteQuery`를 이용해서 더 불러오기 버튼을 쉽게 구현할 수 있다.

**useInfiniteQuery()사용하기**
기존 useQuery를 useInfiniteQuery() 로 바꿔주고, initialPageParam,getNextPageParm옵션을 설정해 줘야한다. 페이지네이션과는 달리 페이지 별로 데이터를 별도로 저장하지 않고 전체 포스트를 한 번에 관리할이기에 쿼리키는 다시 `['posts']`로 변경
```js
import {
	//...
	useInfiniteQuery,
} from '@tanstack/react-query';

//

const {
	data: postsData,
	isPending,
	isError,
} = useInfiniteQuery({
	queryKey: ['posts'],
	queryFn: ({ pageParam  }) => getPosts(pageParam, PAGE_LIMIT),
	initialPageParam: 0,
	getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => lastPage.hasMore ? lastPageParam + 1 : undefined,
});

```
useQuery에서는 데이터가 백엔드에서 받아온 하나의 페이지정보만 담고있다면
useInfiniteQuery()에서는  data.pages에 배열의 형태로 모든 페이지의 정보를 담고 있게 된다.

`['posts',1]`의 쿼리 키로 캐싱 그 이후 다음 페이지로 넘어가면 두 번째 페이지의  데이터를 백엔드로부터 받아 와 역시 해당 데이터만 화면에 보여주고 두번쨰  페이지를 캐싱하겠다.

그런데 useInfiniteQuery에서는 배열안에 지금까지 받아 온 모든 페이지의 데이터가 담기게된다.
1페이지 데이터를 받아오면 0번 인덱스에 해당 데이터가  저장되고, 2페이지로 넘어가면 배열의 1번 인덱스에 데이터가 저장되는 식이다. 하나 배열의 두 페이지의 데이터들이 모두 담겨있으므로 1,2,데이터를 한번에 화면에 보여 줄 수 있다.

**pageParam사용하기**
```js
// initialPageParam으로 초기값을 정함
// lastPage는 현재까지중 가장 마지막 데이터가 전달됨
// allPages로는 모든 페이지의 데이터가 전달됨
// lastPageParam은 현재까지중 가장 마지막 페이지의 설정값
// 즉 2페이지까지 받아 왔다면 lastPageParam은 2가됨
// allPageParams는 모든 페이지의 각각의 페이지 설정값을 가지고 있게 된다.
initialPageParam: 0,
getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
	lastPage.hasMore ? lastPageParam + 1 :  undefined,
```
> getNextPageParam에서 파라미터로 받은 값들의 정보를 이용해 그다음 페이지 값인 pageParam을 리턴해야 한다. 따라서 0페이지의 데이터인 hasMore값을 확인후 트루인  경우 lastPageParam의 값인 0에 1을 더한 값을 1을 리턴하도록 했습니다.
> undefined나 null을 리턴해주면 다음 값이 없다는 것을 의미한다.

```js
// pageParam값은 쿼리 함수의  파라미터로 전달되므로, 이값을 이용해 백엔드에 해당 페이지에 해당하는 데이터를 요청할수있음
queryFn: ({ pageParam }) => getPosts(pageParam, PAGE_LIMIT)
```

### **다음 페이지 불러오기**
useInfiniteQuery의 리턴 값중하나인 fetchNextPage함수를 이용하면 됩니다.
```js
const {
	data: postsData,
	isPending,
	isError,
	fetchNextPage,
} = useInfiniteQuery({
	queryKey: ['posts'],
	queryFn: ({ pageParams }) => getPosts(pageParam, PAGE_LIMIT),
	initialPageParma: 0,
	getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams)  
		lastPage.hasMore ? lastPageParam + 1 : undefined,
	});
	
return (
	// ...
	<div>
		<button onClick={fetchNextPage}>더 불러오기</button>	
	</div>
)
```

**페이지 데이터를 구조에 맞게 정리하기**
pages배열을  Array.map()함수를 돌면서  , 각페이지에 해당하는 포스트 데이터를 모두  보여 주도록변경
```js
const postsPages =  postsData?.pages ?? [];

return (
	...
	<div>
		<ul>
		{postsPages.map((postPage) => 
			postPage.results.map((post) => <Post key={post.id} post={post} />)	
		)}	
		</ul>
	</div>
	,..
);
```
```js
function Post({post}) {
	return (
		<li key={post.id}>
			{post.user.name}: {post.content}	
		</li>	
	);
}

export default Post;
```

**버튼 비활성화 처리하기**
데이터가 없거나 다음 데이터를 불러오는중일때 버튼을 비활성화
```js
const {
	data: postsData,
	isPending,
	isError,
	hasNextPage,
	fetchNextPage,
	isFetchingNextPage,
} = useInfiniteQuery ({
	queryKey: ['posts'],
	queryFn: ({ pageParam }) => getPosts(pageParam, PAGE_LIMIT), 
	initialPageParam: 0,
	getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) 
		=> lastPage.hasMore ? lastPageParam + 1 : undefined,
});
// ...
return (
	...
	<button onClick={fetchNextPage} disabled={!hasNextPage || isFetchingNextPage}> 
		더 불러오기	
	</button>
	...
);
```
