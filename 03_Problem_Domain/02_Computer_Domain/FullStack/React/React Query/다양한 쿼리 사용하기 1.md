## Dependant Query 란?
두 쿼리가 의존관계가 있어 어떤 특정 순서대로 실행
첫  번째 쿼리는 유저의 정보를받아 오고,  두번쨰 쿼리는 바당온 유저의 정보에서 아이디를  이용해 해당 유저의 프로젝트를 받아 오게된다.
```js
const {data:  user} = useQuery({
	queryKey: ['user', email],
	queryFn: getUserByEmail,
});

const userId = user?.id

const {
	data: projects,
} = useQuery({
	queryKey: ['projects', userId],
	queryFn: getProjectsByUser,
});
```
userId값이 있을때만 실행하도록  싶으면 다음과 같이 설정
userId,true,false
```js
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
});

const userId = user?.id

const {
  data: projects,
} = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  enabled: !!userId,
});
```

**usequery()에서 enabled값 사용하기**
로그인기능,
```js
const BASE_URL = '...';
// ...
export async function getUserInfo(username) {
	const response = await fetch(`${BASE_URL}/users/${username}`);
	return await response.json();
}
```
```js
import { useState } from 'react';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { getPosts, uploadPost, getUserInfo } from './api';

function HomePage() {
  const [currentUsername, setCurrentUsername] = useState('');

  // ...

  const { data: userInfoData, isPending: isUserInfoPending } = useQuery({
    queryKey: ['userInfo'],
    queryFn: () => getUserInfo(currentUsername),
    enabled: !!currentUsername,
  });
  
    // ...

  const handleLoginButtonClick = () => {
    setCurrentUsername('codeit');
  };  

  const loginMessage = isUserInfoPending
    ? '로그인 중입니다...'
    : `${userInfoData?.name}님 환영합니다!`;

  if (isPending) return '로딩 중입니다...';

  if (isError) return '에러가 발생했습니다.';

  const posts = postsData?.results ?? [];

  return (
    <>
      <div>
        {currentUsername ? (
          loginMessage
        ) : (
          <button onClick={handleLoginButtonClick}>codeit으로 로그인</button>
        )}
        <form onSubmit={handleSubmit}>
          <textarea
            name="content"
            value={content}
            onChange={handleInputChange}
          />
          <button disabled={!content} type="submit">
            업로드
          </button>
        </form>
      </div>
      <div>
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              {post.user.name}: {post.content}
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

export default HomePage;
```

## Paginated Query
3개씩 끊어서 불러오고,  다음  페이지 버튼을 누르면 그다음  데이터를 3개씩 받아오도록 한다.
page.limit값을  받도록 변경
```js
export async function getPosts(page=0, limit=10) {
	const resposne = await fetch(`${BASE_URL}/posts?page=${page}&limit=${limit}`);
	return await response.json();
}
```

```js
import { useState } from 'react';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { getPosts, uploadPost, getUserInfo } from './api';

const PAGE_LIMIT = 3;

function HomePage() {
  // ...

  const [page, setPage] = useState(0);
  const {
    data: postsData,
    isPending,
    isError,
  } = useQuery({
    queryKey: ['posts', page],
    queryFn: () => getPosts(page, PAGE_LIMIT),
  });

  // ...

  const posts = postsData?.results ?? [];

  return (
    <>
      <div>
        {currentUsername ? (
          loginMessage
        ) : (
          <button onClick={handleLoginButtonClick}>codeit으로 로그인</button>
        )}
        <form onSubmit={handleSubmit}>
          <textarea
            name="content"
            value={content}
            onChange={handleInputChange}
          />
          <button disabled={!content} type="submit">
            업로드
          </button>
        </form>
      </div>
      <div>
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              {post.user.name}: {post.content}
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

export default HomePage;

```
>리액트 쿼리 개발자 도구로 posts 데이터를 살펴보면 hasMore값이 있다.
>hasMore값을 true 로 보내주게된다. 이 hasMore라는 값으로 다음 페이지 버튼을 비활서오하할지 말지를 결정할 수 있다.

> 현재 보이는 데이터가 이전 데이터, 즉 placeholderData라면 다음 페이지 버튼을 비활성화시킨다. 그렇지 않으면 다음 페이지 버튼을 마구 누르는 경우, 존재하지 않는 펭지로 리퀘스트가 간다.

```js
const {
  data: postsData,
  isPending,
  isError,
  isPlaceholderData,
} = useQuery({
  queryKey: ['posts', page],
  queryFn: () => getPosts(page, PAGE_LIMIT),
  placeholderData: keepPreviousData,
});

...

return (
  ...
    <div>
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{`${post.user.name}: ${post.content}`}</li>
      ))}
    </ul>
    <div>
      <button
        disabled={page === 0}
        onClick={() => setPage((old) => Math.max(old - 1, 0))}
      >
        &lt;
      </button>
      <button
        disabled={isPlaceholderData || !postsData?.hasMore}
        onClick={() => setPage((old) => old + 1)}
      >
        &gt;
      </button>
    </div>
  </div>
  
);
```
좀더 심리스한 유저  인터페이스 는 데이터를 프리패치하는 방법도 있다.
1 -> 2로 갈때 데이터를 미리 패치 해 놓기 때문에 다음 페이지로 갈 때 전혀 어색함이나 끊김이 없이 2페이지의 데이터를 보여줄수있다.
```js
...
useEffect(() => {
	if(!isPlaceholderData && postsData?.hasMore) {
		queryClient.prefetchQuery({
			queryKey: ['posts', page + 1],
			queryFn: () => getPosts(page + 1, PAGE_LIMIT),	
		});
	}
}, [isPlaceholderData, postsData, queryClient, page]);
```
