## Optimistic Updates
좋아요 기능같이 유저에게 빠른 피드백을 제공해야 하는 경우에 사용한다. 서버로부터 리스폰스를 기다리지 않고 유저에게 바로 낙관적인 피드백을 주는것이 옵티미스틱 업데이트이다.
좋아요 ->  서버에 반영이 제대로 되었는지 확인하지않음 -> 좋아요 버튼을 누른 것처럼 버튼활성화해서 보여줌

99% 서버에 제대로 반영될 것이고, 만에하나 에러가 발생해도  치명적인 결함이 아니다. 매번 서버 리스폰스를 기다리느니 옵티미스틱 업데이트를 통해  빠른  피드백을 제공하는것이 더좋다.

### **옵티믹스틱 업데이트로 좋아요 구현**
먼저 포스트에 좋아요 데이터를 받아오는 API함수와 특정 포스트에 좋아요, 좋아요 취소를  싱행하는 API함수를  추가한다.
```js
export async function getLikeCountByPostId(postId) {
	const response = await fetch(`${BASE_URL}/posts/${postId}/likes`);
	const body = await respose.json();
	return body.count;
}

export async function getLikeStatusByUsername(postId, username) {
	const response = await fetch(`${BASE_URL}/posts/${postId}/likes/${username}`)
	if (response.status === 200) {
		return true;	
	} else if (response.status === 404) {
		return false;	
	} else {
		throw new Error('Faild...');
	}
}

export async function likePost(postId, username) { 
	const response = await fetch( 
		`${BASE_URL}/posts/${postId}/likes/${username}`,
		 {
			  method: 'POST', 
		 }
	 );
	 
	 if (!response.ok) {
	  throw new Error('Failed to like the post.');
	 }
}

export async function unlikePost(postId, username) {
	const response = await fetch (
		`${BASE_URL}/posts/${postId}/likes/${username}`,	
		{
			method: 'DELETE',	
		}
	);
	
	if(!response.ok) {
		throw new Error('Failed to ...')	
	}
}
```
좋아요 데이터는 포스트 마다 받아온다.
```js
...
return (
	...
	<ul>
		{postPages.map((postPage) => 
			postPage.results.map((post) => (
				<Post
					key={post.id}
					post={post}	
					currentUsername={currentUsername}
				/>
			))	
		)}	
	</ul>
)
```
post컴포안에  좋아요 개수와 현재 유저의  좋아요 여부에 대한  데이터를 받아오는 유저쿼리추가
```js
import { useQuery } from '@tanstack/react-query';
import { getLikeCountByPostId, isPostLikedByCurrentUser } from './api';

function Post({ post, currentUsername }) {
  const { data: likeCount } = useQuery({
    queryKey: ['likeCount', post.id],
    queryFn: () => getLikeCountByPostId(post.id),
  });

  const { data: isPostLikedByCurrentUser } = useQuery({
    queryKey: ['likeStatus', post.id, currentUsername],
    queryFn: () => getLikeStatusByUsername(post.id, currentUsername),
    enabled: !!currentUsername,
  });

  return (
    <li>
      <div>{post.user.name}: {post.content}</div>
      <button>
        {isPostLikedByCurrentUser ? '♥️ ' : '♡ '}
        {`좋아요 ${likeCount ?? 0}개`}
      </button>
    </li>
  );
}

export default Post;

```
이제 뮤테이션 훅을 활용해 좋아요 기능을 옵티미스틱 업데이트로 구현한다.
 onMutate, onError,  onSettled를 활용
 like,unlike따라 각각겡 맞는 API함수를 불러 주는 함수를 정의
 ```js
import { getLikeCountByPostId, getLikeStatusByUsername, likePost, unlikePost } from './api';

// ...

const likesMutation = useMutation({
  mutationFn: async ({ postId, username, userAction }) => {
    if (userAction === 'LIKE_POST') {
      await likePost(postId, username);
    } else {
      await unlikePost(postId, username);
    }
  },
});
// 좋아요 데이터를 리패치하는것을 막기위해  cancelQueries를 실행 좋아요 데이터를 받아오는 쿼리가 실행 중이라면 취소해준다.

const queryClient = useQueryClient();

// ...

const likesMutation = useMutation({
  mutationFn: ...
  onMutate: async ({ postId, username, userAction }) => {
    await queryClient.cancelQueries({ queryKey: ['likeStatus', postId, username] });
    await queryClient.cancelQueries({ queryKey: ['likeCount', postId] });
  },
});

 ```
 좋아요에 대한  쿼리 데이터를 가져와서 유저의 액션에 따라  해당 데이터를 수정한다.
 ```js
 const queryClient = useQueryClient();

// ...

const likesMutation = useMutation({
  mutationFn: ...,
  onMutate: async ({ postId, username, userAction }) => {
    await queryClient.cancelQueries({
      queryKey: ['likeStatus', postId, username],
    });
    await queryClient.cancelQueries({ queryKey: ['likeCount', postId] });

    const prevLikeStatus = queryClient.getQueryData([
      'likeStatus',
      postId,
      username,
    ]);
    const prevLikeCount = queryClient.getQueryData(['likeCount', postId]);

    queryClient.setQueryData(
      ['likeStatus', postId, username],
      () => userAction === 'LIKE_POST'
    );
    queryClient.setQueryData(['likeCount', postId], (prev) =>
      userAction === 'LIKE_POST' ? prev + 1 : prev - 1
    );
  },
});

 ```
 수정하기 전에 데이터를 리턴해준다.
 ```js
 const queryClient = useQueryClient();

// ...

const likesMutation = useMutation({
  mutationFn: ...,
  onMutate: async ({ postId, username, userAction }) => {
    await queryClient.cancelQueries({
      queryKey: ['likeStatus', postId, username],
    });
    await queryClient.cancelQueries({ queryKey: ['likeCount', postId] });

    const prevLikeStatus = queryClient.getQueryData([
      'likeStatus',
      postId,
      username,
    ]);
    const prevLikeCount = queryClient.getQueryData(['likeCount', postId]);

    queryClient.setQueryData(
      ['likeStatus', postId, username],
      () => userAction === 'LIKE_POST'
    );
    queryClient.setQueryData(['likeCount', postId], (prev) =>
      userAction === 'LIKE_POST' ? prev + 1 : prev - 1
    );

    return { prevLikeStatus, prevLikeCount };
  },
});

 ```
 에러가 발생하면 이전에 데이터로  롤백하는 부분은 onError로 추가
 최종코드
 ```js
 import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import {
  getLikeCountByPostId,
  getLikeStatusByUsername,
  likePost,
  unlikePost,
} from './api';

function Post({ post, currentUsername }) {
  const queryClient = useQueryClient();

  const { data: likeCount } = useQuery({
    queryKey: ['likeCount', post.id],
    queryFn: () => getLikeCountByPostId(post.id),
  });

  const { data: isPostLikedByCurrentUser } = useQuery({
    queryKey: ['likeStatus', post.id, currentUsername],
    queryFn: () => getLikeStatusByUsername(post.id, currentUsername),
    enabled: !!currentUsername,
  });

  const likesMutation = useMutation({
    mutationFn: async ({ postId, username, userAction }) => {
      if (userAction === 'LIKE_POST') {
        await likePost(postId, username);
      } else {
        await unlikePost(postId, username);
      }
    },
    onMutate: async ({ postId, username, userAction }) => {
      await queryClient.cancelQueries({
        queryKey: ['likeStatus', postId, username],
      });
      await queryClient.cancelQueries({ queryKey: ['likeCount', postId] });

      const prevLikeStatus = queryClient.getQueryData([
        'likeStatus',
        postId,
        username,
      ]);
      const prevLikeCount = queryClient.getQueryData(['likeCount', postId]);

      queryClient.setQueryData(
        ['likeStatus', postId, username],
        () => userAction === 'LIKE_POST'
      );
      queryClient.setQueryData(['likeCount', postId], (prev) =>
        userAction === 'LIKE_POST' ? prev + 1 : prev - 1
      );

      return { prevLikeStatus, prevLikeCount };
    },
    onError: (err, { postId, username }, context) => {
      queryClient.setQueryData(
        ['likeStatus', postId, username],
        context.prevLikeStatus
      );
      queryClient.setQueryData(['likeCount', postId], context.prevLikeCount);
    },
    onSettled: (data, err, { postId, username }) => {
      queryClient.invalidateQueries({
        queryKey: ['likeStatus', postId, username],
      });
      queryClient.invalidateQueries({
        queryKey: ['likeCount', postId],
      });
    },
  });

  const handleLikeButtonClick = (userAction) => {
    console.log('@@@here', currentUsername);
    if (!currentUsername) return;
    likesMutation.mutate({
      postId: post.id,
      username: currentUsername,
      userAction,
    });
  };

  return (
    <li>
      <div>
        {post.user.name}: {post.content}
      </div>
      <button
        onClick={() =>
          handleLikeButtonClick(
            isPostLikedByCurrentUser ? 'UNLIKE_POST' : 'LIKE_POST'
          )
        }
      >
        {isPostLikedByCurrentUser ? '♥️ ' : '♡ '}
        {`좋아요 ${likeCount ?? 0}개`}
      </button>
    </li>
  );
}

export default Post;

 ```

onSuccess, onError, onSettled는 try-catch-finally하고 비슷함
```js
// onMutate: try시작전 샐행되는 준비단계
try {
	// mutationFn: try블록 내부의 실제 작업
		// onSuccess: try가 성공했을때
} catch {
	//onError: catch블록
} finally {
	//onSettled: finally블록(성공/실패 관계없이 실행)
}
```