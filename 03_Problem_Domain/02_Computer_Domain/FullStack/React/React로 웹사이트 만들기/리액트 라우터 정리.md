## 리액트 라우터란?
리액트에서 경로에 따라 페이지를 나누도록 해주는  라이브러리입니다. 리액트스러운 방법으로 컴포넌트를 사용해서 페이지를 나누는 것이 특징입니다.

## 라우터
BrowserRouter라는 것을 사용했다. 이 컴포넌트를 최상위 컴포넌트에서 감싸주면 모든 곳에서  사용할수있다.
```jsx
import { BrowerRouter} from 'react-router-dom';

function App() {
	return <BrowserRouter> ... </BrowserRouter>
}
```

## 페이지 나누는 방법
routes 컴포넌트 안에다가 route 컴포넌트를 배치해서 각 페이지를 나눠줄 수 있다. 이때 routes안에서는 위에서부터 차례대로  route를 검사 현재 경로와 path prop이 일치하는  route를 찾습니다.
```jsx
<Routes>
	<Route path="/" element={<HomePage />} />
	<Route path="posts" element={<PostListPage />} />
	<Route path="posts/1" element={<PostPage />} />
</Routes>
```

## 링크
\<a>태그 대신에 Link컴포넌트를 사용한다.
 to라는 prop으로 이동할 경로를 정해주면된다. 
 ```jsx
 <Link to="/posts">블로그</Link>
 ```
## 하위 페이지 나누기
route 컴포넌트 안에 route컴포넌트를 배치하면 된다. 하위 페이지에서 최상위 경로에 해당하는 경로는 path prop이 아니라 index라는 prop을 사용하면 된다.
```jsx
<Routes>
  <Route path="/"><HomePage /></Route>
  <Route path="posts" element={<PostLayout />} >
    <Route index element={<PostListPage />}  />
    <Route path="1" element={<PostPage />}  />
  </Route>
</Routes>
```

부모 라우트 컴포넌트에 엘리먼트를 지정하고 아래처럼 Outlet이라는 컴포넌트를 활용하면  공통된 레이아웃을 지정해줄 수 있다.
```jsx
import { Outlet } from 'react-router-dom';

function PostLayout() {
	return(
		<div>
			<h1>Blog</h1>
			<hr />
			<Outlet />	
		</div>	
	);
}

export default PostLayout;
```

## 동적인 경로 다루기
콜론으로 시작하는 문자열을 사용하면 경로에 따라 파라미터를 지정할수있다.
/posts/:postId라는 경로는 /posts/123이라던지

/posts/abc 라는 주소로 접속하면 123이나 abc라는  값을 postId라는 파라미터로 받는다.
```jsx
<Routes>
  <Route path="/"><HomePage /></Route>
  <Route path="posts" element={<PostLayout />} >
    <Route index element={<PostListPage />}  />
    <Route path=":postId" element={<PostPage />}  />
  </Route>
</Routes>
```
경로 파라미터를 사용하려면 useParams 라는 훅을 사용한다.
```jsx
function PostPage() {
	const { postId } = useParams();
}
```

## 쿼리 사용하기
useSearchParams라는  커스텀 훅으로 searchParams객체를 받아올수있다.
이 훅은 서치파람스 객체와 Setter함수를 배열형으로 리턴한다. 이떄 쿼리 값은 searchParams의 get 함수로 가져온다
```jsx
import { useSearchParams } from 'react-router-dom';

function PostListPage() {
	const [searchParams, setSearchParams ] = useSearchParams();
	const filterQuery = searchParams.get('filter');	
}
```
 쿼리 값을 변경하고 주소를  이동하고 싶다면 Setter함수에  객체를 넘겨주면 된다.
 이떄 객체의 프로퍼티로 값을 지정할수있다.
 ```jsx
 // ?filter=react라는 쿼리로 이동하는 예시
 setSearchParams({
	filter: 'react',
 });
 ```

## 페이지 이동하기
리턴값으로 Navigate 컴포넌트를 리턴하면 to prop으로 지정한 경로로 이동
```jsx
function PostPage() {
	const post = getPost(postId);

	// post가 없는 경우 /posts 페이지로 이동
	if(!post) {
		return <Navigate to="/posts" />;	
	}
}
```

## useNavigate Hook
navigate 함수를 가져오면 이 함수를 통해  페이지를 이동할수있다.
```jsx
const navigate = useNavigate();

const handleClick = () => {
	navigate('/wishlist');
}
```

## Link, Navigate, useNavigate 는 언제 사용하는게 좋을까?
모두 페이지 이동,
링크는 사용자가 클릭해서 페이지를 이동하도록 할때 대부분의 경우 링크로 충분

네비게이트 렌더링  시점에 다른 페이지로 이동시키고 싶을 때
- 로그인 없이 들어와서 로그인 페이로 리다이렉트하는경우
- 품절되었거나 상품이 삭제되어  다른 페이지로 이동시키는 경우

useNavigate
특정한 코드의 실행이 끝나고 나서 페이지를 이동시키고 싶을 때 사용하면된다.
- 장바구니 담기  -> 리퀘스트 -> 장바구니 페이지로 이동
 - 결제하기 -> 모든 결제  완료 -> 페이지이동
 - 로그인이 완료된 상태에 처음  진입했던 페이지로 돌아가는 경우

## react-helmet으로 페이지 제목 설정하기
리액트 스러운 방법으로 제목을 바꿀수있는 방법이다.
기존
```jsx
document.title = '...'
```
사용법은 간단
react-helmet 라이브러리 설치후 
```jsx
<Helmet>
	<title>codehat,,,</title></Helmet>
```
헬맷이라는 컴포넌트로  감싼 다음, 안에 title태그를 배치하면 이 컴포넌트가 렌더링 될 때, HTML의 타이틀 태그를 덮어쓸 수 있다.
이름이 헬멧인 이유도 해드 태그에 덮어쓰기 때문

## 싱글 페이지  애플리케이션(SPA) 이해하기

클라이언트사이드 렌더링(Client-side Rendering): 클라이언트는 웹 브라우저 렌더링은 HTML페이지를 만드는 것이다.
> 웹 브라우저에서 자바스크립트로 HTML 페이지를 만드는 것

싱글페이지 애플리케이션(single page Application): 하나의 HTML문서 , 애플리케이션은 여러 페이지를 보여주는 사이트
> 하나의 HTML 문서 안에서 자바스크립트로 여러 페이지를 보여주는 사이트

서버사이드 렌더링(Server-side Rendering)
백엔드 서버에서  리퀘스트를 받으면 상황에 맞는 HTML을 만들어서 리스폰스로 보내주는 방식을 '서버사이드렌더링' 이라고 한다. 서버에서 HTML을 만든다는 뜻이다.
> 서버에서 HTML 을 만들고 리스폰스로 보내주는 것
>> 이미 렌더링  된것을 가져오니 훨씬 빨리 화면을 띄워주고 검색 엔진에서 좋은 점수를 받아 사이트가 잘 노출될수있다는 점이다.

정적 사이트 생성(Static Site Generation)
서버에서 렌더링 하는 것도 좋지만, 데이터가 거의 바뀌지  않는다면 매번 새로만드는것은 낭비
미리 HTML파일로 만들고 이걸 서버로 배포하는 방법을  사용한다.  이런 방식을 '정적 사이트 생성'이라고 한다. 서버에서 리퀘스트가 들어오면
HTML 파일을 읽어서 리스폰스로 보내주는것이다.

##  렌더링을 활용한 리액트 기술 3가지
Next.js: 리액트 서버사이드  렌더링을 편하게
gatsby: 리액트로 정적 사이트 만들기
> npm run build 로 빌드한것처럼  빌드할때 HTML파일로 만든다. Gatsby를 사용하면 손쉽게 HTML 파일로 만들수있다.
react native: 웹과 안드로이드 ios앱에서 사용하는 공통적인 코드를  한번에 개발할 수 있다는  장점이있다.


