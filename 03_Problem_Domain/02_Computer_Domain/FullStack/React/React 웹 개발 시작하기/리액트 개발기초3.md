## children
기본적으로 존재하는 프롭
children프롭
```jsx
//Button.js
function Button({ text }) {
	return <button>{text}</button>
}

export default Button;

//App.js
function App() {
	return (
		<div>
			<div>
				<Button text="throw" />	
				<Button text="throw1" />	
			</div>
			<Dice color="red" num={2} />
		</div>
	)
}
// 이렇게 하는 것보다 children을 활용하여
//Button.js
function Button({ children }) {
	return <button>{children}</button>
}

export default Button;

// App.js
function App() {
	return (
		<div>
			<div>
			<!--이런식으로 여는태그와 닫는태그만 작성해주면되게할수있다.-->
			<!--이런식으로 직관적으로 만들수있다.-->
				<Button>throw</Button>
				<Button>throw</Button>	
			</div>
			<Dice color="red" num={2} />
		</div>
	)
}
```
> 단순히 보여주기만 하는 프롭은 children프롭으로 활용할수있다.

## Props 정리하기
Props는 Properties의 약자이다. 컴포넌트에 속성을 지정해주면 **각 속성이 하나의 객체로 모여서 컴포넌트를 정의한 함수의 첫 번째 파라미터로 전달한다.**

children이라는 조금 특별한 프로퍼티(prop,프롭)가 있다.
JSX문법으로 컴포넌트를 작성할 때 컴포넌트를 단일 태그가 아니라 여는 태그와 닫는 태그의 형태로 작성하면, 그 안에 작성된 코드가 바로 이 children 값에 담기게된다.

어떤 정보를 전달할 때 일반적인 props의 속성값을 주로 활용
화면에 보여질 모습을 조금 더 직관적인 코드로 작성하고자 할 때 children 값을 활용할수있다.

## State
리액트에서는 스테이트만 바꾸면 화면을 알아서 렌더링해준다.
```jsx
import { useState } from 'react';

// setter함수를 통해서만 값변경
// useState(1) 처럼 처음 기본값설정

function random(n) {
	return Math.ceil(Math.random() * n);
}

function App() {
//구조 분해 문법으로 작성한다.
	const [num, setNum] = useState(1);

	const handleRollClick = () => {
		const nextNum = random(6)
		setNum(nextNum);
	};
	
	const handleClearClick = () => {
		setNum(1);
	};
	
	return (
		<div>
			<div>
				<Button onClick={handleRollClick}>던지기</Button>	
				<Button>처음부터</Button>	
			</div>
			<Dice color="red" num={num} />
		</div>
	)
}

// Button.js
function Button({ children, onClick }) {
	return <button onClick={onClick}>{children}</button>
}

export default Button;

```

## 참조형 State
```jsx
import { useState } from 'react';

// setter함수를 통해서만 값변경
// useState(1) 처럼 처음 기본값설정

function random(n) {
	return Math.ceil(Math.random() * n);
}

function App() {
//구조 분해 문법으로 작성한다.
	const [num, setNum] = useState(1);
	// 총 게임점수를 표시
	const [sum, setSum] = useState(0);
	// 기록을 배열로 만들기 위한 스테이트
	// JS에서 배열은 참조형인것을 기억한다
	// 배열의 주소값은 같기때문에 리액트입장에서 요소가 새로 추가되어야지 렌더링하는데 
	// 만약 setNum,setsum이 주석처리 되어서 작동이 안한다면 배열도 작동을 안하게된다.
	// 다만 re-rendering이 되지않았다는거지 실제 array는 업데이트되었따.
	const [gameHistory, setGameHistory] = useState([]);

	const handleRollClick = () => {
		const nextNum = random(6)
		setNum(nextNum);
		// sum과 랜덤번호를 더함
		setSum(sum + nextNum);
		// 빈배열에 푸시
		//ameHistory.push(nextNum);
		//setGameHistory(gameHistory);
		// 아예 새롭게 만든법이다. 구조분해를 해서 새로운 값으로 넣으면된다.
		setGameHistory([...gameHistory,nextNum]);
		
	};
	
	const handleClearClick = () => {
		setNum(1);
		// 클리어시 점수초기화
		setSum(0);
		// 초기값인 빈배열전달
		setGameHistory([]);
	};
	
	return (
		<div>
			<div>
				<Button onClick={handleRollClick}>던지기</Button>	
				<Button>처음부터</Button>	
			</div>
			<div>
				<h2>나</h2>
				<Dice color="red" num={num} />
				<h2>총점</h2>
				<p>{sum}</p>
				<!--쉼표로 연결해서 보여주면됨-->
				<!--join메소드로 배열사이를 연결 시켜 하나의문자열로-->
				<h2>기록</h2>
				<p>{gameHistory.join(', ')}</p>
			</div>
			
		</div>
	)
}

// Button.js
function Button({ children, onClick }) {
	return <button onClick={onClick}>{children}</button>
}

export default Button;

```

```js
const a = [1, 2];    // 1
a.push(3);           // 2
const b = [...a, 4]; // 3
```
```asam
```plaintext
( C언어처럼 주소값을 알 수 있다고 가정하고 표현해 보겠습니다. )

(1)            | (2)             | (3)
               |                 |
(a   : 0x0020) | (a    : 0x0020) | (a    : 0x0020)   (b    : 0x0100)
-  1 : 0x0020  |  -  1 : 0x0020  |  -  1 : 0x0020     -  1 : 0x0100
-  2 : 0x0024  |  -  2 : 0x0024  |  -  2 : 0x0024     -  2 : 0x0104
               |  -  3 : 0x0028  |  -  3 : 0x0028     -  3 : 0x0108
               |                 |                    -  4 : 0x0112
```
```