## 컴포넌트가 좋은 이유
1.반복적인 업무가 줄어든다.
2.고장을 고치기 쉽다.
3.일을 쉽게 나눌수있다. 협업하기 좋다.

>>> 브라우저의 최상단객체는 window객체
>>> 웹 페이지의 최상단객체는 DOM객체
>>> 사실 알고보면 window안에 DOM이들어있기는한데...
## 컴포넌트 재사용하기
최신 문법으로 작성하겠습니다.
```jsx
import Board from './Board';
import { useState } from 'react';
// 하나의 버튼을 누르면 두개의 Boadr가 변해야된다.
// 자식안에 있던 상태를 밖으로 꺼내보았다.

function random(n) {
	return Math.ceil(Math.random() * n);
}

function App() {
	const [num, setNum] = useState(1);
	const [sum, setSum] = useState(0);
	const [gameHistory, setGameHistory] = useState([]);
	const [otherNum, setOtherNum] = useState([]);
	const [otherSum, setOtherSum] = useState(1);
	const [otherGameHistory, setOtherGameHistory] = useState([]);
	
// ...

// 이제 버튼만 누르면 두개의 보드판이 바뀐다.
	return (
			// 버튼 컴포넌트 부분이 들어옴
		<div>
			<Board name="나" color="blue" num={num} sum={sum} gameHistory={gameHistory}/>
			<Board name="상대" color="red" num={otherNum} sum={otherSum} gameHistory={otherGameHistory}/>
		</div>
	)
}

// Board로 파라미터로 전달하고 아규먼트로 전달받는다(검색필요)
function Board({name, color, num, sum, gameHistory})
...
```

## 코드 정리하기
```jsx
import Board from './Board';
import { useState } from 'react';

// 코드 정리를 해준다.
function random(n) {
	return Math.ceil(Math.random() * n);
}

function App() {
// num과 sum은 Board안에 넣는다.
	const [MyHistory, setMyHistory] = useState([]);
	const [otherMyHistory, setOtherMyHistory] = useState([]);
	
// ...

// 이제 버튼만 누르면 두개의 보드판이 바뀐다.
	return (
			// 버튼 컴포넌트 부분이 들어옴
		<div>
			<Board name="나" color="blue" gameHistory={MyHistory}/>
			<Boerd name="상대" color="red" gameHistory={otherGameHistory}/>
		</div>
	)
}

// Board.jsx
function Board({name,color,gameHistory}) {
	const num = gameHistory[gameHistory.length - 1] || 1;
	const sum = gameHisotry.reduce((a,b) => a + b, 0);
}
```

## 리액트가 렌더링하는 방식
VirtuarDOM(가상돔)
> 효율적인 화면처리가 가능하다.

VirtualDOM에서 먼저 적용하고 (반응할 준비만 한다.)DOM에 적용하게된다.

개발자가 돔 트리를 신경쓰지않고 깔끔하게 코드를 작성하게 할수있다.
변경사항들을 효율적으로 처리할수있다.
![[Pasted image 20250825100735.png]]
> state나 ui에 변경이 일어나게 되면 기본적으로 렌더링이 일어난다.
가상돔에 반영된 변경사항이 변경되기전에 DOM을 비교하는 Diffing알고리즘을 통해반영한다.
이 과정을 거치면 변경된 UI를 확인할수있고
위와 같은 과정을 Reconciliation(재조정) 이라고 표현한다.
성능적인 이점을 가져오기위한 동작이라고 이해하면된다.

## 인라인 스타일
문자열이 아닌 객체로 전달해서 인라인스타일로 전달하게된다.
```jsx
// 가능한데 이런방식은 늘어나면 코드 가독성이 떨어진다.
const style = {
 backgroundColor: 'pink',
};

function Button({ children, onClick }) {
	return (
		<button style={ backgroundColor: 'yellow' } onClick={onClick};>
		{children}
		</button>
	)
}

export default Button;
```

```jsx
const baseButtonStyle = {
	padding: '14px 27px',
	borderRadius: '30px',
	outline: 'none',
	cursor: 'pointer',
	fontSize: '17px',
};

const blueButtonStyle = {
	...baseButtonStyle,
	backgroundColor: ...,
	border: ...,
	color: ...,
};

const redButtonStyle = {
	...baseButtonStyle.
	...
};
// 이런식으로 스프래드를 사용해서 필요한코드만 추가해서 사용하게할수있다

// 또한 아래처럼 color가 red일때 red버튼스타일을 적용시킬수있다.
function Button ({ children, onClick, color}){
	const style = color === red ? redButtonStyle : BlueButtonStyle
}

// app.js
<Button color="blue" onClick...
<Button color="red" onClick...
// props는 이렇게 디자인을 변경할때도 사용된다.
```

> innerHTML이 보안적으로 위험한이유는 태그를 넣기떄문에
> ```jsx
> inner.HTML = <script>...</script>
> ```
이러한 식으로 임의코드를 클라이언트에서 실행시킬수있기에 위험하다.
다만 비즈니스 요구사항때문에 사용해야될 일이있을수도있다.




