## 리액트에서 fetch사용하기
```js
export default async function getFoods() {
	const response = await fetch('....');
	const body = await response.json();
	return body;
}
```

## useEffect로 초기 데이터 가져오기
```jsx
// 무한 루프가 발생시 네트워크에서 일시정지버튼을 누른다.
const handleLoad = async() => {
	const { reviews } = await getReviews();
	setItems(reviews);
};

handleLoad();
// state시 app컴포넌트를 재렌더링 그러나 재랜딩하면서 다시 비동기함수가 실행이 된다.
// react에선 이럴때 useEffect문법이 있다
// useEffect가 되면 특별한 경우가 아니면 한번만 실행하게된다.
useEffect(() => {
	handleLoad();
}, []);
```

## 서버에서 정렬한 데이터 받아오기
useEffect를 이용해서 서버에서 정렬한 데이터를 가져온다.
```jsx
// 바로 콜백함수를 호출하는것이 아니라 일단 예약을 하고 끝나면 호출해주는것이다.
// 빈 배열이면 모든 값이 같다는 조건이기에 콜백함수를 실행한다.
// 렌더링이 끝나고 나서 콜백함수는 실행되지않는다.
// 디펜더시 리스트에서 비교해서 기억했던것이랑 달라졌을때 실행해준다.

// order가 의존성배열로 넣어주면 우리가 최신순,베스트순 버튼을 눌렀을때마다 useEffect가 다시 렌더링해줄것이다.
// state로 변화된 order값이랑 order값이랑 다르기때문에 리렌더링 된다.
useEffect(()=>{
	handleLoad();
},[order]);
```
```js
//api.js
export default async function getFoods(order='createAt') {
	const query = `order=${order}`
	const response = await fetch(`..../?${query}`);
	const body = await response.json();
	return body;
}

//main.jsx
const handleLoad = async(orderQuery) => {
	const { reviews } = await getReviews(orderQuery);
	setItems(reviews);
};

// 아규먼트로는 콜백과 의존성배열을 받는다.
useEffect(() => {
	handleLoad(order);
},[order]);
```



