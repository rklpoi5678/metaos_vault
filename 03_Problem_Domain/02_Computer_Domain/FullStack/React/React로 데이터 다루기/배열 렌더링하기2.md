## filter로 아이템 삭제하기'
```js
import mockItems from '../mock.json';

function App() {
	const [items, setItems] = useState(mockItems);
}

const handleDelete = (id) => {
	const nextItems = items.filter((item) => item.id !== id);
	setItems(nextItems);
}

return(
	//...
	<RevewList itmes={sortedItems} onDelete={handleDelte} />

)
```
```jsx
// ReviewList.js
function ReviewList({ items, onDelete }) {
	return (
		//...
			<ReviewListItem item={items} onDelete={onDelete}/>
	)
}

function ReviewListItem({item,onDelete}) {
	const handleDeleteClick = () => onDelete(item.id);
	
	return (
		//...
		
		<button onClick={handleDelete}>삭제</div>
	)
}
```

## 배열을 렌더링 할 땐 key를 기억하세요
mock.json에서 아이디값은 키로쓰기 안성맞춤이다.
```jsx
function ReviewListItem({item,onDelete}) {
	const handleDeleteClick = () => onDelete(item.id);
	
	return (
	//이러식으로 배열을 렌더링할때 id를 줘야 경고가없어진다.
		<li key={item.id}>	
			<button onClick={handleDelete}>삭제</div>
		</li>
	)
}
```
> 사실 배열은 인덱스로 아이디를 사용할수없습니다. 배열은 0번째 부터 시작하기에 엉뚱한곳에 데이터가 삭제될수있다.
> 배열은 배열의순서에 따라 다른 값을 가리킨다.
> 아이디는 항상 상태와 관련없이 고유한값이다. (항상 같은 값을 가리키는 값이면 아이디로 사용할수있다.)

무언가가 삭제되었고, 수정되었다고 결과만 봐서는 사실 알수가없다 그래서 키를 사용하는데
\[
	{key:1, '사과'},
	{key:2, '망고'},
	{key:3, '포도'},
]

key prop은 다른 Prop과 마찬가지로 지정할 수 있는데, 배열을 렌더링 할때 최상위 태그에다가 지정해 주면 된다.
```jsx
function FoodList({items, onDelete}) {
	return (
		<ul className="FoodList">
			{itmes.map((item) => (
				<li key={item.id}>
					<FoodListItem item={item} onDelete={onDelete}	
				</li>
			))}
		</ul>	
	);
}
```

## 배열 렌더링하기
**map으로 렌더링하기**
```jsx
import items from './pokemons';

function Pokemon({ item }) {
	return (
		<div>
			No.{item.id} {item.name}
		</div>
	);
}

function App() {
	return (
		<ul>
			{items.map((item) => (
				<li key={item.id}>
					<Pokemon item={item} />	
				</li>
			))}
		</ul>
	);
}

export default App;
```
```jsx
function App() {
	const renderedItems = items.map((item) => {
		<li key={item.id}>
			<Pokemon item={item} />
		</li>
	});
}
```

**sort로 정렬하기**
```jsx
// id 순서대로/반대로 정렬하는 예시이다.
import {useState} from 'react';
import items from './pokemons';

function Pokemon({ item }) {
	return(
		<div>
			No.{item.id} {item.name}
		</div>
	);
}

function App() {
	const [direction, setDirection] = useState(1);
	const handleAscClick = () => setDirection(1);
	const handleDescClick = () => setDirection(-1);
	
	const sortedItems = items.sort((a,b) => direction * (a.id - b.id));
}

	return (
		<div>
			<div>
				<button onClick={handleAscClick}도감번호 순서대로 </button<
				<button onClick={handleDescClick}도감번호 반대로 </button<
			</div>
			<ul>
				{sortedItems.map((item) => (
					<li key={item.id}>
						<Pokemon item={item} />
					</li>
				))}
			</ul>
		</div>
	);
}

export default App;
```

**filter로 삭제하기**
filter + Array Type State
```jsx
import { useState } from 'react';
import mockItems from './pokemons';

function Pokemon({ item, onDelete }) {
	const handleDeleteClick = () => onDelete(item.id);
	
	return (
		<div>
			No.{item.id} {item.name}
			<button onClick={handleDeleteClick}>삭제</button>
		</div>	
	);
}

function App() {
	const [items, setItems] = useState(mockItems);
}
```

**반드시 key를 내려주자**
최상위 태그에다가 키 프롭을 지정한다.
각 데이터를 구분할 수 있는 고유한 값이면 무엇이든 키로 활용해도 상관없다.
```jsx
import items from './pokemons';

function Pokemon({item}){
	return (
		<div>
			No.{item.id} {item.name}
		</div>
	);
}

function App() {
	return (
		<ul>
			{items.map((item) => {
				<li key={item.name}>
					<Pokemon item={item} />
				</li>
			})}	
		</ul>
	)
}
export default App;
```


