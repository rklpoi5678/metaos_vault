## ref로  DOM 노드 가져오기
원하는 시점에 돔노드에 접근하고 싶을때 ref를 사용한다. 프롭
```jsx
import { useRef } from 'react';

function FileInput({name, value, onChange}) {
	// 특정 DOM요소를 선택하는 요소를 말하낟.
	// 현재 섹션에서는 input type=file에 해당하는 fileInput이 ref
	// 즉, 하단 리턴 인풋에 참조한다 inputRef를 useRef 리액트 사용이다.
	const inputRef = useRef();
	const handleChange = (e) => {
		const nextValue = e.target.files[0];
		onChange(name, nextValue);
	};
	
	useEffect(() => {
		// ref를 쓰면 실제 돔노드를 참조할수있다.
		// dom node는 반드시 렌더링이 끝나야 생기는거니
		// ref의 컴포넌트 값도 화면이 렌더링이 되었을때 존재하는것
		// 조건부를 사용해서 렌더링하면 이값이 없을수도 있다.

		// 그래서 항상 인풋값에 렌더링값이 있을때 사용하는 것을  추천한다.
		if(inputRef.current) {
			console.log(inputRef.current)
		}
		// console.log(inputRef);
	}, []);
	
	return <input type="file" onChange={handleChange} ref={inputRef} />;
}

export default FileInput;
```

##  파일 인풋 초기화
파일 인풋의 밸류속성은 사용자만 바꿀수있고, 자바스크립트로 바꿀떄는 빈문자열로만 바꿀수있다는것
밸류속성을 빈문자열로 바꾸면 선택한 속성을 초기화시킬수있다.
```jsx
import { useRef } from 'react';

function FileInput({name, value, onChange}) {
	// 특정 DOM요소를 선택하는 요소를 말하낟.
	// 현재 섹션에서는 input type=file에 해당하는 fileInput이 ref
	// 즉, 하단 리턴 인풋에 참조한다 inputRef를 useRef 리액트 사용이다.
	const inputRef = useRef();
	const handleChange = (e) => {
		const nextValue = e.target.files[0];
		onChange(name, nextValue);
	};
	
	useEffect(() => {
		// ref를 쓰면 실제 돔노드를 참조할수있다.
		// dom node는 반드시 렌더링이 끝나야 생기는거니
		// ref의 컴포넌트 값도 화면이 렌더링이 되었을때 존재하는것
		// 조건부를 사용해서 렌더링하면 이값이 없을수도 있다.

		// 그래서 항상 인풋값에 렌더링값이 있을때 사용하는 것을  추천한다.
		if(inputRef.current) {
			console.log(inputRef.current)
		}
		// console.log(inputRef);
	}, []);
	
	//버튼에 쓸 함수
	const handleClearClick = () => {
		// inputRef.current 의 값을 inputNode로 할당
		const inputNode = inputRef.current;
		// inputNode가 없다면 작동을 안시밈	(방어 코드)
		if(!inputNode) return;
		// 인풋노드를 일단 초기화
		inputNode.value = '';
		// 이러면 부모 컴포넌트의 값이 null로 변경이 된다.
		onChange(name, null);
	}
	
	return (
	<div>
		<input type="file" onChange={handleChange} ref={inputRef} />;
		{/* 밸류 속성이 있을때만 초기화 할것이다. */}
		{value && <button onClick={handleClearClick}>X</button>}
	</div>
	)
}

export default FileInput;
```

**Ref  객체 생성**
```jsx
import { useRef } from 'react';

// ...

const ref = useRef();
```
> useRef  함수로 Ref객체 만들기 (돔노드 참조j)

**ref Prop사용하기**
```jsx
const ref = useRef();

// . ..

<div ref={ref} > ... </div>
```
>  ref prop에다 앞에서 만든 Ref 객체를 내려준다. (해당 돔이 연결되면서  돔정보를 참조)

**Ref 객체에서 DOM노드 참조하기**
```jsx
const node = ref.current;
if(node){
	// node 를 사용하는 코드
}
```
> ref객체에서 current라는 프로퍼티를  사용하면 DOM 노드를 참조할수있었다.
> !!! current값은 없을 수도 있으니 반드시 값이 존재하는지 검사하고 사용한다는 점!!!

예시: 이미지 크기 구하기
```jsx
import { useRef } from 'react'

function Image({ src }) {
	const imgRef = useRef();
	
	const handleSizeClick = () => {
		const imgNode = imgRef.current;
		if(!imgNode) return;
		
		const { width,  height } = imgNode;
		console.log(`${width} x ${height}`);
	};
	
	return (
		<div>
			<img src={src} ref={imgRef} alt="크기를 구할 이미지" />
			<button onClick={handleSizeClick}>크기 구하기</button>
		</div>
	)
}
```
> img노드의 크기를 ref를 활용하여 출력하는 예시이다./
> img 노드에는 너비 값인 width와 높이 값이인 height라는 속성
> ref  객체의 current 로 dom 노드를 참조해서 두 속성 값을 가져왔다.

## 이미지 파일 미리보기
파일 객체를 Object Url로 만들면 미리보기를 만들수있습니다.
```jsx
import { useRef, useState } from 'react';

function FileInput({name, value, onChange}) {
	const [preview, setPreview] = useState();
	

	useEffect(() => {
	// vlaue 값이 바뀔때마다 프리뷰값을 변경시킬수있다.
	// value값이 없을수 있으니 그럴떄는 종료
		if (!valeu) return;	

	/**
		URL 의 주소는 문자열로 해당값의 주소를 문자열로 쓸수있다.
		returns { String }	
	*/
		const nextPreview = URL.createObjectURL(value);	
		setPreview(nextPreview);
			// 살펴보면 blob로 시작되는 url입보이고 미리보기가 잘생성되었는데 이것이 우리가 설정한 ObjectUrl이다.
		// 메모리를 할당하고 파일에 해당하는 주소를 만들어준다.
		// 컴포넌트 사이드에서 외부 이펙트를 바꾸는것을 사이드이펙트라고 한다.
		// 네트워크의 리퀘스트도 일종의 사이드 이펙트이다.
		// 웹 사이트 리퀘스트를 활용하여 변경하고 리스폰스로 보내기 때문이다.
		// 리액트에서는 사이드이펙트를 다루기 위해 주로 useEffect를 사용한다.
				
	}, [value])
	
	return (
		<div>
			<img src={preview} alt="크기를 구할 이미지" />
			<input type="file" onChange={handleChange} ref={inputRef} />
			<button onClick={handleSizeClick}>크기 구하기</button>
		</div>
	)
}
```

추가적으로 useState의 기본값을 설정안했다면 기본적으로 undefined값이 들어간다.

## 사이드 이펙트 정리하기
파일을 선택할때 마다 메모리를 할당만 한다면 메모리가 낭비될것이다.
```jsx
//useEffect에서 함수를 리턴해주면된다.(사이드 이펙트 정리)
useEffect(() => {
	if (!value) return;
	
	// 이 함수로 인해 사이드이펙트가 발생한다.
	// 콜백함수는 최종적으로 함수를 리턴하게된다.
	const nextPreview = URL.createObjectURL(value);
	setPreview(nextPreview);

	// 나중에 의존성 배열이 바뀌어서 새로 콜백을 실행할텐데
	// 그전에 앞에 정리함수를 실행해서 사이드이펙트를 정리할수있게 해준다.
	return () => {
		// preview state를 해제하고
		// objectURL을 해제한다.
		setPreview();
		URL.revokeObjectURL(nextPreview);	
	}

}, [value])

return (
//
	<input type="file"  accept="image/png, imgae/jpeg.../>
)
```
> ObjectURL 같이 컴포넌트 함수 외부에 부수적인 작용을 만드는 걸 '사이드 이펙트'라고 하였습니다.

## 사이드 이펙트란(Side Effect)?
한국어로 부작용이라는 뜻이다.
감기 증상은 없어지지만(작용), 피부가 붉게 올라오면(부작용) 
이 약에는 부작용이 있다고 할 수 있다.

일상생활에서는 주로 안 좋은 것들을 부작용이라고 부르지만
프로그래밍에선 말 그대로 외부에 부수적인  작용을 하는 것을 말합니다.
```js
let count = 0;

function add(a,b) {
	const result = a + b;
	count += 1 //함수 외부의 값을 변경
	return result;
}

const val1 = add(1,2);
const val2 = add(-4,5);
```
> add함수를  실행하면서 함수 외부의 상태(count변수)가 바뀌기 때문에
> 이런 함수를 "사이드 이펙트가 "  있다고 한다.
> console.log()함수도 값을 계산해서 리턴하는게 아니라
> 웹 브라우저 콘솔 창에 문자열을 출력하니 외부 상태를 변경해서 문자열을 출력하는 것이다.
> 이렇게 함수 안에서 함수 밖에 있는 값이나 상태를 변경하는 것을 '사이드  이펙트'  라고 한다.

### **useEffect**
사이드 이펙트를 실행하고 싶을 때 사용하는 함수이다. DOM Node을 직접 변경한다던지, 브라우저에  데이터를 저장하고, 네트워크 리퀘스트를 보내는 것처럼 말이다.
주로 리액트 외부에 있는 데이터나 상태를 변경할 때 사용한다.
```jsx
useEffect(() => {
	document.title = title; // 페이지 데이터를 변경
}, [title]);

///네트워크 요청
useEffect(() => {
	fetch("https://example.com/data"); // 외부로 네트워크 리퀘스트
	.then((response) => response.json())
	.then((body) => setData(body));
}, []);

// 데이터 저장
useEffect(() => {
	localStorage.setItem('theme',theme) //로컬 스토리지에 테마 정보를 저장
}, [theme]);

// 타이머
useEffect(() => {
	const timerId = setInterval(() => {
		setSecond((prevSecond) => prevSecond + 1);	
	}, 1000); //1초마다 콜백 함수를 실행하는 타이머 시작
	
	return () => {
		clearInterval(timerId);	
	}
}, []);
```
setInterval은 일정시간마다 콜백함수를 실행할수있게 해준다.

## useEffect를 쓰면 좋은경우
'동기화'에 쓰면 유용한 경우가 많다. 동기화는 컴포넌트 안에 데이터와 리엑트 바깥에 있는 데이터를  일치시키는 것을 말한다. 아래는 app컴포넌트는 인풋 입력에 따라 페이지 제목을 바꾸는 컴포넌트이다.
```jsx
// 핸들러 함수만 사용할때
function App() {
	const [title, setTitle] = useState(INITIAL_TITLE);
	
	const handleChange = (e) => {
		const nextTitle = e.target.value;	
		setTitle(nextTitle);
		document.title = nextTitle;
	};
	
	const handleClearClick = () => {
		const nextTitle = INITAL_TITLE;
		setTitle(nextTItle);	
		document.title = nextTitle;
	}
	
	return (
		<div>
			<input value={title} onChange={handleChange} />	
			<button onClick={handleClearClick}>초기화</button>
		</div>	
	);
}

export default App;
```
여기서 document.title 값을 바꾸는 것은 외부의 상태를 변경하는것이니 사이드이펙트이다.
새로 함수를 만들어서 setTitle을  사용하는 코드를 추가할 때마다
document.title값도 변경해야 한다는 것을 기억해뒀다가 관련된 코드를 작성해야 한다는 점이 아쉽다.
useEffect를 사용할경우
```jsx
import { useEffect, useState } from 'react';

const INITAL_TITLE = 'Untitled';

function App() {
	const [title, setTitle] = useState(INITAL_TITLE);
	
	const handleChange = () => {
		const nextTitle = e.target.value;	
		setTitle(nextTitle);
	};
	
	const handleClearClick = () => {
		setTItle(INITAL_TITLE);
	};
	
	useEffect(() => {
		document.title = title;	
	}, [title]);
	
	return (
		<div>
			<input value={title} onChange={handleChange} />
			<button onClick={handleClearClick}>초기화</button>
		</div>	
	)
}
```
사이드 이펙트가 일어나는 부분만 따로 처리하고있다. 이렇게할때 document.title을 변경하는 코드를 신경 쓰지 않아도 되니까 편리하다. 게다가 처음 렌더링 되었을 때 'Untitled'라고 페이지 제목을 변경하는 효과까지 낼수있다.
이렇게 useEffect는 리액트 안과 밖의 데이터를 일치시키는데 활용하면 좋다.
코드를 줄이고, 동작을 쉽게 예측할수있는 코드를 작성할수있기때문이다.

## 정리함수(Cleanup Function)
```jsx
useEffect(() => {
	// 사이드 이펙트
	
	return () => {
		// 사이드 이펙트에 대한 정리
	}
}, [dep1,dep2,dep3, ...]);
```
콜백 함수에서 리턴 값으로 정리하는 함수를 리턴할수있다.
미리보기를 구현할 때 Object URL을 만들어서  브라우저의 메모리를 할당(createObjectURL)했다.  정리 함수에서는 이때 할당한 메모리를 다시 해제(revokeObjectURL)을 해줬다.

### **정리 함수가 실행되는  시점**
콜백을 한 번 실행했으면, 정리 함수도 반드시 한 번 실행된다.
정확히는 새로운 콜백 함수가 호출되기 전에 실행되거나, 컴포넌트가 화면에서 사라지기 전에 실행된다.( 맨 마지막으로 실행한 콜백의 사이드 이펙트를 정리) 

정리  함수를 리턴하면 사이드 이펙트를 정리하고 안전하게 사용할수있다는것이다.