## 비동기로 State를 변경할 때 주의할 점
네트워크에서 스로팅을 확인하면 네트워크 상태를 테스트할때, 오프라인에서 테스트할때

비동기로 받을때 State값이 서로달라 delete를 해도 요소가 삭제되지않게 보이면서 렌더링될때가 있습니다.

이전 스테이트 함수를 사용하고싶다면
이럴떄는 세터함수의 값이 아니라 콜백을전달해야한다는점이다.
이전 state값을 받아서 변경하는곳에 파라미터로 전달하면된다.
```jsx
setItems((prevItems) => {...prevItems}, ...reviews);
```

## useState 뽀개기
**초깃값 지정하기**
```jsx
const [state,setState] = useState(initalState);
```

**콜백으로 초깃값 지정하기**
```jsx
const [state, setState] = useState(() => {
	return initialState;
})
```
즉 초기값을 계산해서 넣는경우인데
```jsx
// `getSavedValues`라는 함수를 통해 컴퓨터에 저장된 초깃값을 가져온다.
// savedValues라는 값은 처음 렌더링한번만 계산 불필요하게 함수를 실행하여 지정된 값을 가져온다.
function ReviewForm() {
	const savedValues = getSavedValues();
	const [values, setValues] = useState(savedValuse);
}
```

**setter**
```jsx
const handleAddClick = () => {
	setState(state + 1);
}

// 참조형 잘못된예
const handleAddClick = () => {
	state.count += 1;
	setState(state);
}

```

## 콜백으로 State변경
```jsx
setState((prevState) => {
	return nextState;
})
```
> 비동기 함수에서 State값을 변경하게되면 최신 값이 아닌 State 값을 참조하는 문제가 있다.
> 이전 스테이트 값으로 새로운 스테이트를 만드는 경우엔 항 상콜백 형태를 사용하는 습관을 들이면 좋다.

```jsx
const [count,setCount] = useState(0);

const handleAddClick = async() => {
	await addCount();
	setCount((prevCount) => prevCount + 1);
}
```

## 네트워크 로딩 처리하기
현재 네트워크 상태에따라 트루 아니면 거짓을 반환하는 리퀘스트를 만듭니다.
```jsx
const [isLoading, setIsLading] = useState(false);

const handleLoad = async(options) => {
	let result;
	try{
		setIsLoading(true);
		result =  const { paging, previous } = await getMovies(options);	
	} catch(error)  {
		console.error(error);	
	} finally {
		setIsLoading(false);
	}
	const {paging, reviews} =  result;
}

// 리퀘스트가 진행중일 때 버튼 비활성화
...

<Button disabled={isLoading} ...
```

## 네트워크 에러 처리하기

```jsx
export async function getReviews({
	order = 'createdAt',
	offset = 0,
	limit = 0,
}) {
	throw new Error('버그가 아니라 기능입니다.')
	const query = `order=${order}$offset=${offset}...`
}

const [isLoading, setIsLading] = useState(false);
const [isLoadingError, setIsLoadingError] = useState(false);

const handleLoad = async(options) => {
	let result;
	try{
		setIsLoading(true);
		setIsLoadingError(null);
		result =  const { paging, previous } = await getMovies(options);	
	} catch(error)  {
		setLoadingError(error);
	} finally {
		setIsLoading(false);
	}
	const {paging, reviews} =  result;
}

// 리퀘스트가 진행중일 때 버튼 비활성화
...

<Button disabled={isLoading} ...
```











