## 리액트에서 입력 폼 만들기
state값과 input의 값을 동일하게 만드는것이 핵심이다.
이것을 제어문이라고한다.
```jsx
function ReviewForm() {
	const [title, setTitle] = useState('');

	// setTitle에 현재 인풋값을 넣어 동기화
	const handleTitleChange = (e) => {
		setTitle(e.target.value);
	}

	return (
		<form>
		{/** 리액트에선 바닐라 자바스크립트의 onChange이벤트랑 다르게  동작한다. 사용자가 인풋을 할때 마다 input 이벤트가 발생, 리액트를 만든 장본인이 onChange가 더 직관적이어서 이렇게 만들었다고 한다. */}

			<input value={title} onChange={handleTItleChange}></input>	
		</form>	
	)
}

export default ReviewForm;
```

## onSubmit 을 써보자
```jsx
const handelSubmit = () => {
	console.log({
		title,
		rating,
		content,
	});
}
return (
	<form className="reviewForm" onSubmit={handleSubmit}>
		<button type='submit'>확인</button>
	</form>
)
```

## 하나의 state로 폼 구현하기 
```jsx
function ReviewForm()  {
	const [value, setValues] = useState({
		title: '',
		rating: 0,
		content: '',
	});
	
	const handleChange = (e) => {
		const {name, value} = e.target; 
			setValeu((prevValues) => ({
				...prevValues,
				[name]: value,
		}));
	}
	
	const handleSubmit = (e) => {
		e.preventDefault();
		console.log(values);	
	};
	
	return (
		<form className="ReviewForm" onSubmit={handleSubmit}>
			<input name="title" value={value.title} onChange={handleChange} />
			<input name="title" type="num" value={value.rating} onChange={handleChange}  />
			<textarea name="title" value={value.content} onChange={handleChange} />
			<button type="submit">확인</button>
		</form>
	)
}
```
> 이제 입력시 인풋값이 변할떄마다 스테이트가 변한다.

리액트에서는 불변성이라는 개념이 존재한다. 리액트는 렌더링여부를 판단할때 state의 상태값을 변화함에 따라서 값을 변경하는데 이때 해당  state를 비교할때 **얕은 비교를**수행하게 된다.
즉,
```jsx
const [values, setvalues] = useState({
	title: '',
	rating: 0,
	content: '',
});
```
해당값의 상태가 바꼈다면 렌더링을 통해 값을 변경시켜주고 바뀌지 않았다면 변경시키지 않고 최적화를 진행해야 하기 때문에 ,현재는 state를 변경시키기 위해 spread연산자를 통해 값을 변경하고있다.

## 제어 컴포넌트와 비제어 컴포넌트
제어 컴포넌트(Controlled Component): input의 value값을 리액트에서 지정
```jsx
const handleChange(e) => {
	const nextValue = e.target.value.upperCase();
	setValue(nextValue);
};

	return <input value={value} onChange={handleChange}/>; 
```
> 동작을 예측하기 쉽고, 쉽게 바꿀수있고 직관적인 장점이있다. 대부분 제어컴포넌트를 추천
> 다만 경우에 따라서는  비제어 컴포넌트도 사용해야한다.

비제어 컴포넌트(Uncontrolled Component): value 값을 지정하지않음
실제 인풋값이랑 리액트에서 돌려주는것이랑 다를때
```jsx
const handleChange(e) => {
	const nextValue = e.target.value.upperCase();
	setValue(nextValue);
};

	return <input onChange={handleChange}/>; 
```

## 입력 폼 쪼개기
HTML과 다른 점
 onChange: 순수 HTML과 다르게 onChange  Prop를 사용하면 입력 값이 바뀔 때마다 핸들러 함수를 실행합니다. oninput이벤트와 같아고 생각하면된다.

```jsx
function TripSearchFrom() {
	const [location,  setLocation] = useState('Seoul');
	const [checkIn, setCheckIn] = useState('2022-01-01');
	const [checkOut, setCheckOut] = useState('2022-01-02');
	
	const handleLocationChange = (e) => setLocation(e.target.value);
	
	const handleCheckInChange = (e) => setCheckIn(e.target.value);
	
	const handleCheckOutChange = (e) => setCheckOut(e.target.value);
	
	return (
		<form>
			<h1>검색 시작하기</h1>	
			<label htmlFor="location">위치</label>
			<input id="location" value={location} name="location" placeholder="어디로 여행가세요.." onChange={handleLocationChange} />
			...
		</form>
	)
}
```

## 폼 값을 객체 하나로 처리하기
이벤트 객체의 target.name, target.value값을 사용해서 값을 변경해줄수있다.
```jsx
function TripSearchForm() {
	const [values, setValues] = useState({
		location: 'Seoul',
		checkIn: '2022-01-01',
		checkOut: '2022-01-02',
	})
	
	const  handleChange = (e) => {
		const {name,value} = e.target;
		setValues((prevValues) =({
			...preValues,
			[name]: value,	
		}));
	}
	return ( <form> <h1>검색 시작하기</h1> <label htmlFor="location">위치</label> <input id="location" name="location" value={values.location} placeholder="어디로 여행가세요?" onChange={handleChange} /> <label htmlFor="checkIn">체크인</label> <input id="checkIn" type="date" name="checkIn" value={values.checkIn} onChange={handleChange} /> <label htmlFor="checkOut">체크아웃</label> <input id="checkOut" type="date" name="checkOut" value={values.checkOut} onChange={handleChange} /> <button type="submit">검색</button> </form> ) }
}
```

기본 서브밋 동작막기
->  e.preventDefault();

**제어 컴포넌트**
리액트에서 인풋의 값을 제어하는 경우로 리액트에서 지정한 값과 실제 인풋 밸류의 값이 항상 같다.
state, prop  중요하지 않고 리액트로 밸류를 지정한다는것이다.

**비제어 컴포넌트**
인풋 태그의 밸류 속성을 리액트에서 지정하지 않고 사용하는 컴포넌트 이다.
대표적으로 파일을 선택하는 인풋이 그러하다.

**만약 제어 컴포, 비제어 컴포 모두 쓸수있는 경우 제어 컴포넌트를 사용하는것을 추천한다.**

## 파일 인풋
```jsx
import {useState} from 'react';

function FileInput() {
	const [value, setValue] = useState();
	
	const handleChange = (e) => {
		
	}
}
```