## 나만의 훅으로  코드 정리하기
이러한 나만의 훅을 모아두는것을 커스텀훅이라고 한다.
커스텀 훅은 src/hook폴더안에 만든다.
```jsx
// 다른 개발자도 알수있게 use를 앞에 붙인다.
// asyncFunction을 파라미터로 받고
function useAsync(asyncFunction) {
 // 로딩 상테,에러,콜백 함수를 실행할 함수를 배열형태로 리턴할것
 const [pending, setPending] = useState(false);
 const [error, setError] = useState(null);

 // 원하는 함수를 씌운다는 네임
 const wrapperFunction = async(...args) => {
	try{
		setError(null);
		setPending(true);
		return await asyncFunction(...args);	
	} catch (error) {
		setError(error);
		return;	
	} finally {
		setPending(false);	
	}
 }
 return [pending, error, wrapperFunction];
}

export default useAsync;
```

## useCallback
```jsx
// 무한루프에 빠질때 useCallback을 사용한다.
useEffect(() => {
	handleLoad({ order, offset: 0, limit: LIMIT});
}, [order, handleLoad]);
```
함수를 기억해놓았다가 재사용할수있다.
함수를 새로만드는것이 아니라 재사용하는것
> 의존성 배열에서 오류가 넣어주면  해당  함수를 넣어줘야하는것
```jsx
const handleLoad = useCallback(async (options) => {
	const result = await getReviewsAsync(options);
	if(!result) return;
	...
})
```

## exhaustive-deps규칙
리액트에서는 Prop이나 State와 관련된 값은 되도록이면 빠짐없이 디펜던시에 추가해서 항상 최신 값으로 useEffect나 useCallback을 사용하도록 권장한다.

**usellback으로 함수 재사용하기**
디펜던시 리스트에 추가한 함수가 매번 바뀌는 문제를 해결하려면 함수를 useCallback으로 감싸주면된다. 리액트에다 함수를 기억시키고, 이때 리액트는 useCallback의 디펜던시 리스트 값이 바뀔 때만 함수를 새로 만들어준다.
> 이런식으로 컴포넌트 안에서 만든 함수를 디펜던시 리스트에 사용할 때는 useCallback 훅으로 매번 함수를 새로 생성하는 걸 막는다.

## 훅의 규칙
- 반드시 컴포넌트 함수 안에서 사용해야 함
- 컴포넌트 함수의 최상위에서만 사용 (조건문,반복문은 안에서 못쓴다는 말이다.)

useState
```jsx
const [state, setState] = useState(initialState);
```
callback으로 초기값
```jsx
const [state, setState] = useState(() => {
	// ...
	return initialState;
})
```
State변경
```jsx
setState(nextState);
```

## 이전 State을 참조해서 State 변경
비동기 함수에서 최신 State값을 가져와서 새로운 State값을 만들 때
```jsx
setState((prevState) => {
	//...
	return nextState
});
```

**useEffect**
컴포넌트 함수에서 사이드 이펙트(리액트 외부의 값이나 상태를 변경할 때)에 활용하는 함수

**처음 렌더링후 한번만 실행**
```jsx
useEffect(() => {
	// ...
}, []);
```

**렌더링 후에 특정 값이 바뀌었으면 실행**
- 처음 렌더링 후에도 한 번 실행됨
```jsx
useEffect(() => {
	// ...
}, [dep1,dep2,dep3,dep4])
```

## 사이드 이펙트 정리하기(CleanUp)
```jsx
useEffect(() => {
 // 사이드 이펙트
 
 return () => {
	// cleanUp 
 }
},[dep1,dep2,dep3])
```

## useRef
생성하고 돔노드에 연결
```jsx
const ref = useRef();
//...

return <div ref={ref}>Hello</div>
```
DOM노드 참조하기
```jsx
const node = ref.current;
if(node) {
	//node를 사용하는 코드
}
```

## useCallback
함수를 매번  실행하는것이  아니라 디펜던시 리스트가 변경될  때만 함수를 생성
```jsx
const handleLoad = useCallback((option) => {
	// ...
}, [dep1,dep2,dep3])
```

## Custom Hook
자주 사용하는 훅 코드들을 모아서 함수로 만들 수 있었는데
use000 처럼  use를 붙인다.
다양한 커스텀 훅이 소개되어있는 사이트 참고

## useAsync
비동기 함수의 로딩, 에러 처리를 하는 데 사용할 수 있는 함수
함수를 asyncFunction 이라는 파라미터로 추상화해서
wrappedFunction이라는 함수를 만들어 사용하는 방식

## useToggle
toggle함수를 호출할 때마다 value값이 참/거짓으로 번갈아가며 바뀐다.
ON/OFF스위치
```jsx
function useToggle(initialValue = false) {
	const [value,setValue] = useState(initialValue);
	const toggle = () => setValue((prevValue) => !prevValue)
	return [value, toggle];
}
```

## useTimer
start를 실행하면 callback이라는 파라미터로 넘겨 준 함수를 timeout밀리초 마다  실행하고, stop을 실행하면 멈춘다. 실행할때마다 사이드 이펙트를 만들고, 사용하지 않으면 정리해줘야한다.
clearInterval이라는 함수를 실행하여 사이드 이펙트 정리
```jsx
function useTimer(callback, timeout) {
	const [isRunning,setIsRunning] = useState(false);
	const start = () => setIsRunning(true);
	const stop = () => setIsRunnning(false);
	
	useEffect(() => {
		if(!isRunning) return;
		
		const timerId = setInterval(callback, timeout) //사이드 이펙틉 발생	
		return () => {
			clearInterval(timeId); // 사이드 이펙트 정리	
		};
	}, [isRunning, callback, timeout])
}
```