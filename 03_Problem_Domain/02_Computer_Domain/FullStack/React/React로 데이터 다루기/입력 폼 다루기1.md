## 글 수정하기1
```jsx
function ReviewList({ items, onDelete }) {
	// 리뷰리스트의 아이디
	const [editingId, setEditinId ] = useState(null);
	
	if (item.id ===  editingId) {
		return (
			<li key={item.id}>
				<ReviewListItem />
			</li>	
		)	
	} 
}

// ReviewList.js
function ReviewListItem({ item, onDelete, onEdit }) {
	const handleDeleteClick = () => {
		onDelete(item.id);
	};
	
	const handleEditClick = () => {
		onEdit(item.id);	
	}
	
	return(
		// ... 수정버튼을 추가해준다.
		<button onClick={handleEditClick}>수정</button>	
	)
}

	<ReviewListItem  item={item} onDelete={onDelete} onEdit={setEditingId}
```
```jsx
//ReviewForm.js

// prop에 상수를 넣고 props를 이용하여 값 스테이트에 프롭을 넣음
function ReviewForm({ initialValues = INITIAL_VALUES, onSubmitSuccess, onCancel }) {
	const [values, setValues] = useState(initalValues);
	
	return (
	// onCancel시에만 보이도록 추가
		{onCancel && <button onClick={onCancel}>취소</button>}	
	)
}
```

## 글 수정하기 2
```jsx
export const function updateReview(id, formData) 
	const response = await fetch(`${BASE_URL}/film-reviews/${id}`), {
		method: 'PUT',
		body, formData,	
	});
	if (!response.ok) return new Error(`Error:${response.status}`)
	
	const body = response.json();
	return body;
}

// app.js

const handleUpdateSuccess = (review) => {
	setItems((prevItems) => {
		const splitIdx = prevItems.findIndex((item) => item.id === review.id);	
		return [ 
			...prevItems.slice(0, splitIdx),
			review,
			...prevItems.slice(splitIdx + 1),	
		]	
	})
}

function ReviewList({ items, onDelete,  onUpdate, onUpdateSucess})

<ReviewList items={sortedItems} onDelte={handleDelete} onUpdate={updateReview}  onUpdateSuccess={handeleUpdateSuccess} />
```

## 글 삭제하기
```jsx
export const function deleteReview(id) 
	const response = await fetch(`${BASE_URL}/film-reviews/${id}`), {
		method: 'DELETE',
		body, formData,	
	});
	if (!response.ok) return new Error(`리뷰를 삭제하는데 실패했습니다.`)
	
	const body = response.json();
	return body;
}

// app.js
const handleDelete = async(id) => {
	const result = await deleteReview(id);
	if (!result) return;

	//아래 코드는 비동기 함수이므로
	//const nextItems = items.filter((item) => item.id !== id)	
	//setItems(nextItems);
	
	// 이런식으로 콜백을 사용해야되겠다.
	setItems((prevItmes) => prevItems.filter((item) =>  item.id !== id))
}
```

## 리액트 Hook
리액트에서 use로 시작하는말 ReactHook
프로그래밍에서 훅이란  내가 작성한 코드를 **다른 프로그램에 연결**해서, **그 값이나 기능을 사용하는 것**

useState는 리액트가 관리하는 State에 연결해서 변수처럼 값을 사용
useEffect는 내 콜백 함수를 리액트에 연결해서 렌더링 후에  함수 실행!
useRef는 리액트가 관리하는 Ref 객체에 연결해서 current값을 사용한다.

## 리액트 훅의 규칙
리액트 훅은 리액트 컴포넌트안에서 사용해야한다.
```jsx
const [value,setValue] = useState();
// reactHook 위반
function Star  ...
```
리액트에서는 반복문을 사용할수없다. 리액트 훅은 항상 렌더링순서에 맞게 실행되어야한다. 실행한 순서대로 연결된다. 그래서 반복문 조건문 안에서는 리액트 훅을 사용할수없다는 규칙이 있다.
```jsx
function start ...
	const states = [];
	for(let i=0; i<9; i++) {
		const state = useState();
		states.push(state)	
	}
```
