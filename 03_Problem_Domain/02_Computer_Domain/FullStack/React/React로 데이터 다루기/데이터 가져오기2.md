## useEffect 살펴보기
**처음 한 번만 실행하기**
```jsx
useEffect(() => {
	// execute code
},[])
```
> 첫 렌더싱 되고 나면 리액트가 콜백 함수를 기억해뒀다가 실행
> 그 이후로는 콜백 함수를 실행하지 않는다.

**값이 바뀔 때마다 실행하기**
```jsx
useEffect(() => {
	// execute code
},[dep1,dep2,dep3,...]);
```
> ... 그 이후로 렌더링시 디펜던시 리스트에 있는 값들을 확인해서
> 하나라도 바뀌면 콜백 함수를 기억해뒀다가 실행한다.

## 페이지네이션이란?
(Paginnation); 책의 페이지처럼 **데이터를 나눠서** 제공하는 것
(많은 양의 데이터를 조금씩 받아오는것)
- **오프셋**기반 페이지네이션
	- Offest: 상쇄하다, 지금까지 받아온 데이터의 개수
```request
GET https://example.com/posts?offset=20&limit=10
```
> **지금까지 20개**받았으니 **10개** 더 보내줘
```response
{
	"paging": {
		"count": 30,
		"hasNext": false
	},
	"posts": [...]
}
```
오프셋기반을 일허게 받아올 데이터와 받아온 데이터를 사용한다.
오프셋기반에서는 중복되거나, 삭제할시 다음으로 넘어갈때 빠지는경우가 생겨 커서 기반 페이지네이션이 생겨났다.
- **커서**기반 페이지네이션
Cursor: 데이터를 가리키는 값, 지금까지 받은 데이터를 표시한 **책갈피**

```request
GET https://example.com/posts?limit=10
```
> 데이터 10개 보내줘
```response
{
	"paging": {
		"count": 30,
		"nextCursor": "WerZxc"	
	},
	"posts": [...]
}
```
> 페이징에 다음 커서값정보가 들어가있다. 
```request
GET https:/example.com/posts?cursor=WerZxc&limit=10
```
> 커서 데이터 이후로 10개 보내줘

커서가 있어서 데이터가 바뀌어도
중복되거나 삭제되어도 삭제된만큼 잘가져옵니다.

다만 서버입장에서도 만들기 까다롭고, 정말 필요한게 아니라면 오프셋기반이 편하다.

- 오프셋 기반 = 받아온 개수 기준
- 커서 기반 = 데이터를 가리키는 커서 기준

## 데이터 더 불러오기
```jsx
export async function getReviews((order='createdAt', offset=0, limit-=0)=>{
	const query = `order=${order}&offset=${offset}&limit=${limit}`
})
	const response = await fetch(`https://learn....?${query}`)
	const body = await response.json();
	return body;
```
```jsx
// main.jsx

const LIMIT = 6;

const [offset, setOffset] = useState(0);
const [hasNext, setHasNext] = useState(false);

const handleLoad = async (options) => {
	const { reviews, paging } = await getReview(options);
	if (options.offset === 0) {
		setItem(reviews);	
	} else {
		setItem({...items, ...reviews});
	}
	setOffset(options,offset + reviews.length);
	setHasNext(paging.hasNext);
};

const handleLoadMore = () => {
	handleLoad({ order, offset, limit: LIMIT});
}

useEffect(() => {
	handleLoad({ order, offset: 0, limit: LIMIT});
}, [order]);

return (

	 // ...
	 <button disabled={!hasNext} onClick={handleLoadMore}>LoadMore</button>
)
```
> 페이징네이션 더 불러오는 데이터가 없으면 더보기 버튼을 비활성화

## 데이터가 있을 때만 버튼 보여주기
```jsx
// 버튼을 비활성화하지말고 데이터가 다 나왔을때 버튼자체를 숨기기
{hasNext && <Button onClick={handleLoadMore}>
	더보기
</Button>}
```
> hasNext가 참일때 연산자에 뒤에있는  Button 이 렌더링된다.
> 이런것을 조건문 렌더링이라고 한다.


