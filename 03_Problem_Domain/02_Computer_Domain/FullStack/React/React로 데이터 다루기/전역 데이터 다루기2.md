## Context 코드 분리하기
```jsx
import { createContext } from 'react';

const LocaleContext = createContext();

export function LocaleProvider({ defaultValue="ko", children }) {
	//app 의 로켈을 가져옴
	const [locale, setLocale] = useState(defaultValue);
	return <LocaleContext.Provider value=({
		locale, setLocale	
	})>{children}</LocaleContext.Provider>
}

export function useLocale() {
	const context = useContext(LocaleContext);
	// 실수록 컨텍스트 밖에서 사용했을경우 에러가나옵니다.
	if(!context) {
		throw new Error("반드시 LocaleProvider 안에서 사용해야 합니다.");	
	}
	
	return context.locale;
}

export function useSetLocale() {
	const context = useContext(LocaleContext);
	// 실수록 컨텍스트 밖에서 사용했을경우 에러가나옵니다.
	if(!context) {
		throw new Error("반드시 LocaleProvider 안에서 사용해야 합니다.");	
	}
	
	return context.locale;
}


export default LocaleContext;
```
맥락을 분리하면 나중에 더 안전하게 분리할수있다.

## 다국어 기능 완성하기
이러한 경우는 딕셔너리를 사용한다. 언어가 바뀔떄마다 사전만  바뀌면되니까
```jsx
// dick['ko']['apple'] =>
// dict['en']['apple'] =>
// dict['vn']['apple'] =>
```
```jsx
// useTranslate.js
const dict = {
	ko: {
		'confirm button': '확인',
		...
	},
	en: {
	}
}

import { useLocale } from '../contexts/LocaleContext';
function useTranslate() {
//useLocale 커스텀훅을 통해 받을 로켈을 맥락안에서 적용시킬수있다.
	const locale = useLocale();
	// 빈 문자열이 들어올경우 or 연산자로 빈문자열을 리턴
	const translate = (key) => dict[locale][key] || '';
	return translate;
}

export default useTranslate;

// ReviewList.js
const t = useTranslate();

retrun (
// 수정버튼을 커스텀훅을 사용하고 번역된 글자를 를 넣는다
// 앞에서 작성한 로켈관련은 지운다
	<button onClick={handleEditClick}>{t('edit button')}</button>
	<button onClick={handleDeleteClick}>{t('delete button')}</button>
)
// 다른 폴더에서도 비슷하게 적용한다.
```

## 리액트 Context
한국어로 맥락이라는 뜻이다. 어떤 상황에 대한 정보를 의미한다.
'사용자가 한국어를 사용하는 상황','사용자가 영어를 사용하는 상황' 여러 컴포넌트에 공유하고 싶을 때 사용한다.

Props만으로  리액트 개발을 하다 보면 여러 곳에 쓰이는 데이터를 내려주고 싶을 때가 있는데,
이때 컴포넌트의 단계가 많다면 여러 번 반복해서 Prop을 내려줘야한다.
이런 문제점을 프롭 드릴링이라고 한다.
> Context는 이런 프롭 드릴링을 해결하기 위해 사용하는 기능이다.

**Context 만들기**
createContext라는 함수를 통해 만들수있다.
```jsx
import { createContext } from 'react';

const LocaleContext = createContext();
```
아래처럼  기본값을 넣어줄 수 있다.
```jsx
import { createContext } from 'react';

const LocaleContext = createContext('ko');
```

**Context 적용하기**
맥락을 쓸 때는 반드시 값을 공유할 범위를 정하고 써야 한다.
Context객체에 있는 Provider라는 컴포넌트로 정해줄수있다.
Provider의 value prop으로 공유할 값을 내려주면 된다.
```jsx
import { createContext } from 'react';

const LocaleContext = createContext('ko');

function App() {
	return (
		<div>
			... 바깥의 컴포넌트에서는 LocaleContext 사용불가	
		
			<LocaleContext.Provider value="en">
				... Provider 안의 컴포넌트에서는 LocaleContext 사용가능
			</LocaleContext.Provider>
		
		</div>	
	);
}
```

**Context값 사용하기**
useContext 라는 훅을 사용하면 값을 가져와  사용할 수 있다.
이떄 아규먼트로는  사용할 Context를 넘겨주면 된다.
```jsx
import { createContext, useContext } from 'react';

const LocaleContext = createContext('ko');

function Board() {
	const locale = useContext(LocaleContext);
	return <div>언어: {locale}</div>
}

function App() {
	return(
		<div>
			<LocaleContext.Provider value="en">
				<Board />	
			</LocaleContext.Provider>		
		</div>	
	);
}
```

## State, Hook와 함께 활용하기
Provider  역할을 하는 컴포를 하나 만들고, 여기서 State를 만들어 value로 넘겨줄 수 있다.
그리고 아래의 useLocale같이 useContext를 사용해서 값을 가져오는 커스텀 훅을 만들 수도 있고
이렇게 하면 Context에서 사용하는 State값은 반드시 우리가 만든 함수를 통해서만 쓸 수 있기 때문에 안전한 코드를 작성하는데 도움이된다.
```jsx
import { createContext, useContext } from 'react';

const LocaleContext = createContext();

export function LocaleProvider({ children }) {
	const [locale, setLocale] = useState();
	return(
		<LocaleContext.Provider value={{ locale, setLocale }}>
			{children}	
		</LocaleContext.Provider>
	);
}

export function useLocale() {
	const context = useContext(LocaleContext);
	
	if(!context) {
		throw new Error('반드시 LocaleProvider 안에서 사용해야 한다.');	
	}
	
	const { locale } = context;
	return locale;
}

export function useSetLocale() {
	const context = useContext(LocaleContext);
	
	if(!context) {
		throw new Error('반드시 LocaleProvider 안에서 사용해야 합니다.');	
	} const { setLocale } = context; return setLocale;
}
```

## 상태 관리의 짧은  역사
State Management: 상태관리 - 화면에서 사용하는 데이터를 관리하는 것
옛날에도 콘텍스트 문법은 있었지만 나중에는 누가 데이터를 바꿨는지 알기힘들었다.(언제 어디서 누가 바꾸는지 알려면 코드를 한참뒤져야했다.)

그래서 페이스북에서는 Flux라는 라이브러리를 만들게된다. - 데이터의 변경을 한 곳에서 하면서 흐름을 정리하게 하는 라이브러리
데이터를 변경하고 싶으면 컴포넌트에서 액션을 만들어서, Dispatcher에 전달하고 디스패쳐는 액션을 모아서  Store에  전달, 스토어는 데이터가 들어오는것을보고 차례로 데이터를 변경한다.

스토어의 데이터가  다시 컴포넌트로 데이터가 들어오면 컴포넌트는 다시 렌더링을 한다.
컴포넌트에서는 액션만 신경쓰면되고 , 스토어에서는 변경만 신경쓰면된다. 디스페쳐에서 들어오는 액션을 차례로 살펴보기만 하면되게 만들었다.

이  Flux에 영감을 받아 만든것이 Redux이다. 그러나 처음엔 좋다가 리덕스에 개발자들이 데이터를 추가하다  너무 많은데이터가 적재되었다. 개발자들이 데이터 하나를 추가하기위해 무의미한 리덕스코드를 양산했다. 또한 리덕스로 비동기 처리를 하려면 코드가 더러워지고 알아보기 힘들었다.

이에 불만을 가진 개발자들이 ,  Client-state와 Server-state로 구분하여(구분하는 기준은 데이터의 출처) 프론트엔드 개발자들은 클라이언트 사이드에만 집중하고, 서버사이드는 서버와 동기화하면 되지않을까하는 아이디어에서 출발 그것에 2019년 출발한 React Query와 SWR의 등장이다.

이 라이브러리들은 리퀘스트를 정해놓으면 알아서 서버와 동기화하기때문에, 편하게 서버상태관리를 할수있었다. 또 다른 한편으로는  아주 단순한 상태관리 라이브러리를 만들려는 시도가있었다. 2020년 페이스북에서 Recoil이라는 라이브러리 발표(전역적으로 쓸수있는 useState와 비슷) 공유한 콘텍스트들을 따로 분리하면 어떨까? 리코일에서는 이러한 것을 Atom이라고 부른다F