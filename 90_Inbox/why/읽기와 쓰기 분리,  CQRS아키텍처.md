## 핵심
명령과 조회의 책임 분리 패턴을  쓰는 이유가, 읽기와 쓰기가 한 데이터베이스를바라본다면 주문 폭주시 읽기 요청은 폭주하는데 (data connection Pool)이 소진이된다. 그러면  정작  중요한 돈이 되는 주문인 처리(쓰기)가 불가능해질수있다.
-> 근본적으로 해결하기위해 명령과 조회의 책임 분리

상태를 변경하는 명령과 상태를 조회하는 쿼리로 명확히 분리, 각각에 최적화된 시스템을 구축하는것이다.
- Command명령 모델:  일관성이 중요할때 안정적인 트랜잭션 데이터베이스(AWS Aurora) 에서 처리한다.
- Query(조회) 모델: 읽기 작업은 별도의 조회 전용 데이터 저장소를 사용한다.
- Redis (MaterializedView형태로  Reids에 저장하는 방식이다.)

데이터 동기화문제는 AWS DMS나 Kafka같은 이벤트 스트리밍 기술을 활용하여, 쓰기 데이터베이스의 변경  로그를 실시간 감지하고 조회용  Redis에 반영하는 방식이다.

무진장 타임세일처럼 특정 시간에 트래픽이 몰릴 것이 명백한 상황에서 이 **콜드 스타트** 문제는 재앙이 될 수 있습니다. 이벤트 시작 정각에 수만 명의 사용자가 동시에 새로고침 버튼을 누르거나 주문을 한다면(그림1), 이 모든 요청이 캐시 미스를 일으켜 원본 데이터베이스로 한꺼번에 몰리는 ‘**캐시 스탬피드(Cache Stampede)**’ 현상을 유발할 수 있습니다. 이는 이벤트가 시작되기도 전에 시스템 전체를 마비시킬 수 있는 최악의 시나리오입니다.